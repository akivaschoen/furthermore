;; Analyzed by ClojureScript 0.0-3119
{:use-macros nil, :excludes #{}, :macros {unsafe-bit-and {:ns cljs.core, :name cljs.core/unsafe-bit-and, :file "cljs/core.clj", :column 1, :line 516, :macro true, :arglists ([x y] [x y & more]), :cljs.analyzer/numeric true}, unchecked-remainder-int {:ns cljs.core, :name cljs.core/unchecked-remainder-int, :file "cljs/core.clj", :column 1, :line 423, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, when-first {:ns cljs.core, :name cljs.core/when-first, :file "clojure/core.clj", :column 1, :line 4230, :macro true, :arglists ([bindings & body]), :doc "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"}, cond->> {:ns cljs.core, :name cljs.core/cond->>, :file "clojure/core.clj", :column 1, :line 6899, :macro true, :arglists ([expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression."}, bit-set {:ns cljs.core, :name cljs.core/bit-set, :file "cljs/core.clj", :column 1, :line 556, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, import-macros {:ns cljs.core, :name cljs.core/import-macros, :file "cljs/core.clj", :column 1, :line 47, :macro true, :arglists ([ns [& vars]])}, while {:ns cljs.core, :name cljs.core/while, :file "clojure/core.clj", :column 1, :line 5824, :macro true, :arglists ([test & body]), :doc "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil"}, satisfies? {:ns cljs.core, :name cljs.core/satisfies?, :file "cljs/core.clj", :column 1, :line 1316, :macro true, :arglists ([psym x]), :doc "Returns true if x satisfies the protocol"}, unchecked-subtract-int {:ns cljs.core, :name cljs.core/unchecked-subtract-int, :file "cljs/core.clj", :column 1, :line 429, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, bit-shift-right {:ns cljs.core, :name cljs.core/bit-shift-right, :file "cljs/core.clj", :column 1, :line 547, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, aget {:ns cljs.core, :name cljs.core/aget, :file "cljs/core.clj", :column 1, :line 358, :macro true, :arglists ([a i] [a i & idxs])}, specify {:ns cljs.core, :name cljs.core/specify, :file "cljs/core.clj", :column 1, :line 695, :macro true, :arglists ([expr & impls]), :doc "Identical to specify but does not mutate its first argument. The first\n  argument must be an ICloneable instance."}, vswap! {:ns cljs.core, :name cljs.core/vswap!, :file "cljs/core.clj", :column 1, :line 1965, :macro true, :arglists ([vol f & args]), :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in."}, caching-hash {:ns cljs.core, :name cljs.core/caching-hash, :file "cljs/core.clj", :column 1, :line 568, :macro true, :arglists ([coll hash-fn hash-key])}, bit-shift-left {:ns cljs.core, :name cljs.core/bit-shift-left, :file "cljs/core.clj", :column 1, :line 544, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, coercive-not {:ns cljs.core, :name cljs.core/coercive-not, :file "cljs/core.clj", :column 1, :line 278, :macro true, :arglists ([x])}, dec {:ns cljs.core, :name cljs.core/dec, :file "cljs/core.clj", :column 1, :line 478, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, < {:ns cljs.core, :name cljs.core/<, :file "cljs/core.clj", :column 1, :line 453, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, this-as {:ns cljs.core, :name cljs.core/this-as, :file "cljs/core.clj", :column 1, :line 705, :macro true, :arglists ([name & body]), :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."}, .. {:ns cljs.core, :name cljs.core/.., :file "clojure/core.clj", :column 1, :line 1540, :macro true, :arglists ([x form] [x form & more]), :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand."}, delay {:ns cljs.core, :name cljs.core/delay, :file "cljs/core.clj", :column 1, :line 1346, :macro true, :arglists ([& body])}, unchecked-negate {:ns cljs.core, :name cljs.core/unchecked-negate, :file "cljs/core.clj", :column 1, :line 417, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, simple-benchmark {:ns cljs.core, :name cljs.core/simple-benchmark, :file "cljs/core.clj", :column 1, :line 1880, :macro true, :arglists ([bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]), :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case."}, unchecked-inc-int {:ns cljs.core, :name cljs.core/unchecked-inc-int, :file "cljs/core.clj", :column 1, :line 408, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, js-str {:ns cljs.core, :name cljs.core/js-str, :file "cljs/core.clj", :column 1, :line 1945, :macro true, :arglists ([s])}, bit-shift-right-zero-fill {:ns cljs.core, :name cljs.core/bit-shift-right-zero-fill, :file "cljs/core.clj", :column 1, :line 550, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, implements? {:ns cljs.core, :name cljs.core/implements?, :file "cljs/core.clj", :column 1, :line 1296, :macro true, :arglists ([psym x]), :doc "EXPERIMENTAL"}, pos? {:ns cljs.core, :name cljs.core/pos?, :file "cljs/core.clj", :column 1, :line 487, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, specify! {:ns cljs.core, :name cljs.core/specify!, :file "cljs/core.clj", :column 1, :line 687, :macro true, :arglists ([expr & impls]), :doc "Identical to reify but mutates its first argument."}, if-not {:ns cljs.core, :name cljs.core/if-not, :file "clojure/core.clj", :column 1, :line 726, :macro true, :arglists ([test then] [test then else]), :doc "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil."}, alength {:ns cljs.core, :name cljs.core/alength, :file "cljs/core.clj", :column 1, :line 1768, :macro true, :arglists ([a])}, bit-xor {:ns cljs.core, :name cljs.core/bit-xor, :file "cljs/core.clj", :column 1, :line 527, :macro true, :arglists ([x y] [x y & more]), :cljs.analyzer/numeric true}, doseq {:ns cljs.core, :name cljs.core/doseq, :file "cljs/core.clj", :column 1, :line 1618, :macro true, :arglists ([seq-exprs & body]), :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil."}, unsigned-bit-shift-right {:ns cljs.core, :name cljs.core/unsigned-bit-shift-right, :file "cljs/core.clj", :column 1, :line 553, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, neg? {:ns cljs.core, :name cljs.core/neg?, :file "cljs/core.clj", :column 1, :line 490, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, unchecked-float {:ns cljs.core, :name cljs.core/unchecked-float, :file "cljs/core.clj", :column 1, :line 387, :macro true, :arglists ([x])}, undefined? {:ns cljs.core, :name cljs.core/undefined?, :file "cljs/core.clj", :column 1, :line 332, :macro true, :arglists ([x]), :doc "Return true if argument is identical to the JavaScript undefined value."}, deftype {:ns cljs.core, :name cljs.core/deftype, :file "cljs/core.clj", :column 1, :line 975, :macro true, :arglists ([t fields & impls]), :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields"}, mask {:ns cljs.core, :name cljs.core/mask, :file "cljs/core.clj", :column 1, :line 560, :macro true, :arglists ([hash shift])}, when-let {:ns cljs.core, :name cljs.core/when-let, :file "clojure/core.clj", :column 1, :line 1741, :macro true, :arglists ([bindings & body]), :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test"}, divide {:ns cljs.core, :name cljs.core/divide, :file "cljs/core.clj", :column 1, :line 448, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, coercive-boolean {:ns cljs.core, :name cljs.core/coercive-boolean, :file "cljs/core.clj", :column 1, :line 290, :macro true, :arglists ([x])}, <= {:ns cljs.core, :name cljs.core/<=, :file "cljs/core.clj", :column 1, :line 458, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, if-some {:ns cljs.core, :name cljs.core/if-some, :file "clojure/core.clj", :column 1, :line 1756, :macro true, :arglists ([bindings then] [bindings then else & oldform]), :doc "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else"}, * {:ns cljs.core, :name cljs.core/*, :file "cljs/core.clj", :column 1, :line 437, :macro true, :arglists ([] [x] [x y] [x y & more]), :cljs.analyzer/numeric true}, min {:ns cljs.core, :name cljs.core/min, :file "cljs/core.clj", :column 1, :line 499, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, lazy-seq {:ns cljs.core, :name cljs.core/lazy-seq, :file "cljs/core.clj", :column 1, :line 1338, :macro true, :arglists ([& body]), :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls."}, js-delete {:ns cljs.core, :name cljs.core/js-delete, :file "cljs/core.clj", :column 1, :line 303, :macro true, :arglists ([obj key])}, truth_ {:ns cljs.core, :name cljs.core/truth_, :file "cljs/core.clj", :column 1, :line 295, :macro true, :arglists ([x])}, defcurried {:private true, :ns cljs.core, :name cljs.core/defcurried, :file "cljs/core.clj", :column 1, :line 586, :macro true, :arglists ([name doc meta args & body]), :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param"}, js-debugger {:ns cljs.core, :name cljs.core/js-debugger, :file "cljs/core.clj", :column 1, :line 309, :macro true, :arglists ([]), :doc "Emit JavaScript \"debugger;\" statement."}, let {:ns cljs.core, :name cljs.core/let, :file "cljs/core.clj", :column 1, :line 163, :macro true, :arglists ([bindings & body]), :doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein."}, -> {:ns cljs.core, :name cljs.core/->, :file "clojure/core.clj", :column 1, :line 1558, :macro true, :arglists ([x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc."}, coercive-not= {:ns cljs.core, :name cljs.core/coercive-not=, :file "cljs/core.clj", :column 1, :line 282, :macro true, :arglists ([x y])}, doto {:ns cljs.core, :name cljs.core/doto, :file "clojure/core.clj", :column 1, :line 3533, :macro true, :arglists ([x & forms]), :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"}, areduce {:ns cljs.core, :name cljs.core/areduce, :file "cljs/core.clj", :column 1, :line 1788, :macro true, :arglists ([a idx ret init expr]), :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret."}, double {:ns cljs.core, :name cljs.core/double, :file "cljs/core.clj", :column 1, :line 382, :macro true, :arglists ([x])}, bit-and-not {:ns cljs.core, :name cljs.core/bit-and-not, :file "cljs/core.clj", :column 1, :line 531, :macro true, :arglists ([x y] [x y & more]), :cljs.analyzer/numeric true}, unchecked-add-int {:ns cljs.core, :name cljs.core/unchecked-add-int, :file "cljs/core.clj", :column 1, :line 393, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, fn {:ns cljs.core, :name cljs.core/fn, :file "clojure/core.clj", :column 1, :line 4143, :macro true, :arglists ([& sigs]), :doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function"}, short {:ns cljs.core, :name cljs.core/short, :file "cljs/core.clj", :column 1, :line 380, :macro true, :arglists ([x])}, js-this {:private true, :ns cljs.core, :name cljs.core/js-this, :file "cljs/core.clj", :column 1, :line 702, :macro true, :arglists ([])}, unchecked-double {:ns cljs.core, :name cljs.core/unchecked-double, :file "cljs/core.clj", :column 1, :line 388, :macro true, :arglists ([x])}, string? {:ns cljs.core, :name cljs.core/string?, :file "cljs/core.clj", :column 1, :line 320, :macro true, :arglists ([x])}, js-arguments {:ns cljs.core, :name cljs.core/js-arguments, :file "cljs/core.clj", :column 1, :line 300, :macro true, :arglists ([])}, unchecked-multiply-int {:ns cljs.core, :name cljs.core/unchecked-multiply-int, :file "cljs/core.clj", :column 1, :line 414, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, as-> {:ns cljs.core, :name cljs.core/as->, :file "clojure/core.clj", :column 1, :line 6913, :macro true, :arglists ([expr name & forms]), :doc "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form."}, when-not {:ns cljs.core, :name cljs.core/when-not, :file "clojure/core.clj", :column 1, :line 477, :macro true, :arglists ([test & body]), :doc "Evaluates test. If logical false, evaluates body in an implicit do."}, when {:ns cljs.core, :name cljs.core/when, :file "clojure/core.clj", :column 1, :line 471, :macro true, :arglists ([test & body]), :doc "Evaluates test. If logical true, evaluates body in an implicit do."}, int {:ns cljs.core, :name cljs.core/int, :file "cljs/core.clj", :column 1, :line 524, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, > {:ns cljs.core, :name cljs.core/>, :file "cljs/core.clj", :column 1, :line 463, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, keyword? {:ns cljs.core, :name cljs.core/keyword?, :file "cljs/core.clj", :column 1, :line 355, :macro true, :arglists ([x])}, unchecked-multiply {:ns cljs.core, :name cljs.core/unchecked-multiply, :file "cljs/core.clj", :column 1, :line 411, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, gen-apply-to {:ns cljs.core, :name cljs.core/gen-apply-to, :file "cljs/core.clj", :column 1, :line 1915, :macro true, :arglists ([])}, some->> {:ns cljs.core, :name cljs.core/some->>, :file "clojure/core.clj", :column 1, :line 6934, :macro true, :arglists ([expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc"}, unchecked-dec {:ns cljs.core, :name cljs.core/unchecked-dec, :file "cljs/core.clj", :column 1, :line 396, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, defn {:ns cljs.core, :name cljs.core/defn, :file "clojure/core.clj", :column 1, :line 266, :macro true, :arglists ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]), :doc "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions."}, float {:ns cljs.core, :name cljs.core/float, :file "cljs/core.clj", :column 1, :line 381, :macro true, :arglists ([x])}, js-in {:ns cljs.core, :name cljs.core/js-in, :file "cljs/core.clj", :column 1, :line 306, :macro true, :arglists ([key obj])}, es6-iterable {:ns cljs.core, :name cljs.core/es6-iterable, :file "cljs/core.clj", :column 1, :line 1948, :macro true, :arglists ([ty])}, amap {:ns cljs.core, :name cljs.core/amap, :file "cljs/core.clj", :column 1, :line 1773, :macro true, :arglists ([a idx ret expr]), :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret."}, declare {:ns cljs.core, :name cljs.core/declare, :file "clojure/core.clj", :column 1, :line 2795, :macro true, :arglists ([& names]), :doc "defs the supplied var names with no bindings, useful for making forward declarations."}, - {:ns cljs.core, :name cljs.core/-, :file "cljs/core.clj", :column 1, :line 432, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, hash-set {:ns cljs.core, :name cljs.core/hash-set, :file "cljs/core.clj", :column 1, :line 1727, :macro true, :arglists ([] [& xs])}, or {:ns cljs.core, :name cljs.core/or, :file "cljs/core.clj", :column 1, :line 256, :macro true, :arglists ([] [x] [x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil."}, assert-args {:private true, :ns cljs.core, :name cljs.core/assert-args, :file "cljs/core.clj", :column 1, :line 90, :macro true, :arglists ([fnname & pairs])}, extend-type {:ns cljs.core, :name cljs.core/extend-type, :file "cljs/core.clj", :column 1, :line 886, :macro true, :arglists ([type-sym & impls]), :doc "Extend a type to a series of protocols. Useful when you are\n   supplying the definitions explicitly inline. Propagates the\n   type as a type hint on the first argument of all fns.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y & zs] ...))"}, bit-test {:ns cljs.core, :name cljs.core/bit-test, :file "cljs/core.clj", :column 1, :line 541, :macro true, :arglists ([x n])}, defmethod {:ns cljs.core, :name cljs.core/defmethod, :file "cljs/core.clj", :column 1, :line 1867, :macro true, :arglists ([multifn dispatch-val & fn-tail]), :doc "Creates and installs a new method of multimethod associated with dispatch-value. "}, time {:ns cljs.core, :name cljs.core/time, :file "cljs/core.clj", :column 1, :line 1872, :macro true, :arglists ([expr]), :doc "Evaluates expr and prints the time it took. Returns the value of expr."}, zero? {:ns cljs.core, :name cljs.core/zero?, :file "cljs/core.clj", :column 1, :line 484, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, unchecked-dec-int {:ns cljs.core, :name cljs.core/unchecked-dec-int, :file "cljs/core.clj", :column 1, :line 399, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, memfn {:ns cljs.core, :name cljs.core/memfn, :file "clojure/core.clj", :column 1, :line 3550, :macro true, :arglists ([name & args]), :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls."}, js-obj {:ns cljs.core, :name cljs.core/js-obj, :file "cljs/core.clj", :column 1, :line 1750, :macro true, :arglists ([& rest])}, nil? {:ns cljs.core, :name cljs.core/nil?, :file "cljs/core.clj", :column 1, :line 274, :macro true, :arglists ([x])}, extend-protocol {:ns cljs.core, :name cljs.core/extend-protocol, :file "clojure/core_deftype.clj", :column 1, :line 807, :macro true, :arglists ([p & specs]), :doc "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))"}, cond-> {:ns cljs.core, :name cljs.core/cond->, :file "clojure/core.clj", :column 1, :line 6885, :macro true, :arglists ([expr & clauses]), :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression."}, dotimes {:ns cljs.core, :name cljs.core/dotimes, :file "cljs/core.clj", :column 1, :line 1799, :macro true, :arglists ([bindings & body]), :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1."}, bit-and {:ns cljs.core, :name cljs.core/bit-and, :file "cljs/core.clj", :column 1, :line 511, :macro true, :arglists ([x y] [x y & more]), :cljs.analyzer/numeric true}, reify {:ns cljs.core, :name cljs.core/reify, :file "cljs/core.clj", :column 1, :line 631, :macro true, :arglists ([& impls]), :doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (-seq f)))))\n  == (\\f \\o \\o))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}"}, instance? {:ns cljs.core, :name cljs.core/instance?, :file "cljs/core.clj", :column 1, :line 340, :macro true, :arglists ([t o])}, load-file* {:ns cljs.core, :name cljs.core/load-file*, :file "cljs/core.clj", :column 1, :line 1973, :macro true, :arglists ([f])}, defonce {:ns cljs.core, :name cljs.core/defonce, :file "cljs/core.clj", :column 1, :line 86, :macro true, :arglists ([x init])}, unchecked-add {:ns cljs.core, :name cljs.core/unchecked-add, :file "cljs/core.clj", :column 1, :line 390, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, rfn {:private true, :ns cljs.core, :name cljs.core/rfn, :file "cljs/core.clj", :column 1, :line 603, :macro true, :arglists ([[f1 k] fkv]), :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl."}, identical? {:ns cljs.core, :name cljs.core/identical?, :file "cljs/core.clj", :column 1, :line 337, :macro true, :arglists ([a b])}, unchecked-divide-int {:ns cljs.core, :name cljs.core/unchecked-divide-int, :file "cljs/core.clj", :column 1, :line 402, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, defn- {:ns cljs.core, :name cljs.core/defn-, :file "clojure/core.clj", :column 1, :line 4529, :macro true, :arglists ([name & decls]), :doc "same as defn, yielding non-public def"}, defprotocol {:ns cljs.core, :name cljs.core/defprotocol, :file "cljs/core.clj", :column 1, :line 1199, :macro true, :arglists ([psym & doc+methods]), :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17"}, unchecked-subtract {:ns cljs.core, :name cljs.core/unchecked-subtract, :file "cljs/core.clj", :column 1, :line 426, :macro true, :arglists ([& xs]), :cljs.analyzer/numeric true}, assert {:ns cljs.core, :name cljs.core/assert, :file "cljs/core.clj", :column 1, :line 1517, :macro true, :arglists ([x] [x message]), :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true."}, true? {:ns cljs.core, :name cljs.core/true?, :file "cljs/core.clj", :column 1, :line 314, :macro true, :arglists ([x])}, array {:ns cljs.core, :name cljs.core/array, :file "cljs/core.clj", :column 1, :line 1674, :macro true, :arglists ([& rest])}, letfn {:ns cljs.core, :name cljs.core/letfn, :file "clojure/core.clj", :column 1, :line 6033, :macro true, :arglists ([fnspecs & body]), :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body."}, / {:ns cljs.core, :name cljs.core//, :file "cljs/core.clj", :column 1, :line 443, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, bitpos {:ns cljs.core, :name cljs.core/bitpos, :file "cljs/core.clj", :column 1, :line 564, :macro true, :arglists ([hash shift])}, bit-or {:ns cljs.core, :name cljs.core/bit-or, :file "cljs/core.clj", :column 1, :line 520, :macro true, :arglists ([x y] [x y & more]), :cljs.analyzer/numeric true}, vector {:ns cljs.core, :name cljs.core/vector, :file "cljs/core.clj", :column 1, :line 1696, :macro true, :arglists ([] [& xs])}, >= {:ns cljs.core, :name cljs.core/>=, :file "cljs/core.clj", :column 1, :line 468, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, loop {:ns cljs.core, :name cljs.core/loop, :file "cljs/core.clj", :column 1, :line 175, :macro true, :arglists ([bindings & body]), :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target."}, bit-flip {:ns cljs.core, :name cljs.core/bit-flip, :file "cljs/core.clj", :column 1, :line 538, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, js-mod {:ns cljs.core, :name cljs.core/js-mod, :file "cljs/core.clj", :column 1, :line 505, :macro true, :arglists ([num div]), :cljs.analyzer/numeric true}, with-out-str {:ns cljs.core, :name cljs.core/with-out-str, :file "cljs/core.clj", :column 1, :line 1925, :macro true, :arglists ([& body]), :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls."}, condp {:added "1.0", :ns cljs.core, :name cljs.core/condp, :file "cljs/core.clj", :column 1, :line 1388, :macro true, :arglists ([pred expr & clauses]), :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown."}, cond {:ns cljs.core, :name cljs.core/cond, :file "clojure/core.clj", :column 1, :line 558, :macro true, :arglists ([& clauses]), :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil."}, some-> {:ns cljs.core, :name cljs.core/some->, :file "clojure/core.clj", :column 1, :line 6923, :macro true, :arglists ([expr & forms]), :doc "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc"}, ns-interns {:ns cljs.core, :name cljs.core/ns-interns, :file "cljs/core.clj", :column 1, :line 1954, :macro true, :arglists ([[quote ns]]), :doc "Returns a map of the intern mappings for the namespace."}, for {:ns cljs.core, :name cljs.core/for, :file "cljs/core.clj", :column 1, :line 1531, :macro true, :arglists ([seq-exprs body-expr]), :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"}, binding {:ns cljs.core, :name cljs.core/binding, :file "cljs/core.clj", :column 1, :line 1375, :macro true, :arglists ([bindings & body]), :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values."}, array-map {:ns cljs.core, :name cljs.core/array-map, :file "cljs/core.clj", :column 1, :line 1707, :macro true, :arglists ([] [& kvs])}, unchecked-byte {:ns cljs.core, :name cljs.core/unchecked-byte, :file "cljs/core.clj", :column 1, :line 384, :macro true, :arglists ([x])}, unchecked-short {:ns cljs.core, :name cljs.core/unchecked-short, :file "cljs/core.clj", :column 1, :line 386, :macro true, :arglists ([x])}, inc {:ns cljs.core, :name cljs.core/inc, :file "cljs/core.clj", :column 1, :line 481, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, with-redefs {:ns cljs.core, :name cljs.core/with-redefs, :file "cljs/core.clj", :column 1, :line 1353, :macro true, :arglists ([bindings & body]), :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing."}, bit-clear {:ns cljs.core, :name cljs.core/bit-clear, :file "cljs/core.clj", :column 1, :line 535, :macro true, :arglists ([x n]), :cljs.analyzer/numeric true}, list {:ns cljs.core, :name cljs.core/list, :file "cljs/core.clj", :column 1, :line 1691, :macro true, :arglists ([] [x & xs])}, + {:ns cljs.core, :name cljs.core/+, :file "cljs/core.clj", :column 1, :line 373, :macro true, :arglists ([] [x] [x y] [x y & more]), :cljs.analyzer/numeric true}, aset {:ns cljs.core, :name cljs.core/aset, :file "cljs/core.clj", :column 1, :line 365, :macro true, :arglists ([a i v] [a idx idx2 & idxv])}, defmulti {:ns cljs.core, :name cljs.core/defmulti, :file "cljs/core.clj", :column 1, :line 1823, :macro true, :arglists ([mm-name & options]), :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy"}, str {:ns cljs.core, :name cljs.core/str, :file "cljs/core.clj", :column 1, :line 224, :macro true, :arglists ([& xs])}, coercive-= {:ns cljs.core, :name cljs.core/coercive-=, :file "cljs/core.clj", :column 1, :line 286, :macro true, :arglists ([x y])}, hash-map {:ns cljs.core, :name cljs.core/hash-map, :file "cljs/core.clj", :column 1, :line 1717, :macro true, :arglists ([] [& kvs])}, if-let {:ns cljs.core, :name cljs.core/if-let, :file "clojure/core.clj", :column 1, :line 1721, :macro true, :arglists ([bindings then] [bindings then else & oldform]), :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else"}, false? {:ns cljs.core, :name cljs.core/false?, :file "cljs/core.clj", :column 1, :line 317, :macro true, :arglists ([x])}, case {:ns cljs.core, :name cljs.core/case, :file "cljs/core.clj", :column 1, :line 1446, :macro true, :arglists ([e & clauses]), :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type."}, exists? {:ns cljs.core, :name cljs.core/exists?, :file "cljs/core.clj", :column 1, :line 324, :macro true, :arglists ([x]), :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript."}, bit-not {:ns cljs.core, :name cljs.core/bit-not, :file "cljs/core.clj", :column 1, :line 508, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, byte {:ns cljs.core, :name cljs.core/byte, :file "cljs/core.clj", :column 1, :line 379, :macro true, :arglists ([x])}, max {:ns cljs.core, :name cljs.core/max, :file "cljs/core.clj", :column 1, :line 493, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, == {:ns cljs.core, :name cljs.core/==, :file "cljs/core.clj", :column 1, :line 473, :macro true, :arglists ([x] [x y] [x y & more]), :cljs.analyzer/numeric true}, lazy-cat {:ns cljs.core, :name cljs.core/lazy-cat, :file "cljs/core.clj", :column 1, :line 1936, :macro true, :arglists ([& colls]), :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"}, comment {:ns cljs.core, :name cljs.core/comment, :file "clojure/core.clj", :column 1, :line 4341, :macro true, :arglists ([& body]), :doc "Ignores body, yields nil"}, defrecord {:ns cljs.core, :name cljs.core/defrecord, :file "cljs/core.clj", :column 1, :line 1131, :macro true, :arglists ([rsym fields & impls]), :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values."}, make-array {:ns cljs.core, :name cljs.core/make-array, :file "cljs/core.clj", :column 1, :line 1683, :macro true, :arglists ([size])}, unchecked-negate-int {:ns cljs.core, :name cljs.core/unchecked-negate-int, :file "cljs/core.clj", :column 1, :line 420, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, unchecked-inc {:ns cljs.core, :name cljs.core/unchecked-inc, :file "cljs/core.clj", :column 1, :line 405, :macro true, :arglists ([x]), :cljs.analyzer/numeric true}, and {:ns cljs.core, :name cljs.core/and, :file "cljs/core.clj", :column 1, :line 238, :macro true, :arglists ([] [x] [x & next]), :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true."}, number? {:ns cljs.core, :name cljs.core/number?, :file "cljs/core.clj", :column 1, :line 349, :macro true, :arglists ([x])}, symbol? {:ns cljs.core, :name cljs.core/symbol?, :file "cljs/core.clj", :column 1, :line 352, :macro true, :arglists ([x])}, when-some {:ns cljs.core, :name cljs.core/when-some, :file "clojure/core.clj", :column 1, :line 1776, :macro true, :arglists ([bindings & body]), :doc "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test"}, unchecked-char {:ns cljs.core, :name cljs.core/unchecked-char, :file "cljs/core.clj", :column 1, :line 385, :macro true, :arglists ([x])}, ->> {:ns cljs.core, :name cljs.core/->>, :file "clojure/core.clj", :column 1, :line 1574, :macro true, :arglists ([x & forms]), :doc "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc."}}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {StringBuffer goog.string.StringBuffer, garray goog.array, goog.array goog.array, gobject goog.object, goog.object goog.object, goog.string goog.string, gstring goog.string}, :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:arglists (quote ([meta hash-map __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :end-column 27, :end-line 7654, :column 10, :line 7654, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashSet, :variadic false, :max-fixed-arity 3}), :line 7654, :end-line 7654, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, js->clj {:protocol-inline nil, :meta {:arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :end-column 14, :end-line 8982, :column 7, :line 8982, :file "cljs/core.cljs"}, :name cljs.core/js->clj, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([x] [x opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 8982, :end-line 8982, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :test true}, sort-by {:protocol-inline nil, :meta {:arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-column 14, :end-line 1978, :column 7, :line 1978, :file "cljs/core.cljs"}, :name cljs.core/sort-by, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 3}), :line 1978, :end-line 1978, :max-fixed-arity 3, :fn-var true, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ITransientAssociative {:meta {:protocol-info {:methods {-assoc! [[tcoll key val]]}}, :protocol-symbol true, :doc "Protocol for adding associativity to transient collections.", :end-column 35, :end-line 561, :column 14, :line 561, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column 1, :line 561, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 561, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections.", :test true}, chunk-first {:protocol-inline nil, :meta {:arglists (quote ([s])), :end-column 18, :end-line 3024, :column 7, :line 3024, :file "cljs/core.cljs"}, :name cljs.core/chunk-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3024, :end-line 3024, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, m3-hash-int {:protocol-inline nil, :meta {:arglists (quote ([in])), :tag number, :end-column 26, :end-line 697, :column 15, :line 697, :file "cljs/core.cljs"}, :name cljs.core/m3-hash-int, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 697, :ret-tag number, :end-line 697, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, stepper {:protocol-inline nil, :meta {:arglists (quote ([xform iter])), :end-column 14, :end-line 3428, :column 7, :line 3428, :file "cljs/core.cljs"}, :name cljs.core/stepper, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3428, :end-line 3428, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :test true}, pr-str* {:protocol-inline nil, :meta {:arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :end-column 14, :end-line 645, :column 7, :line 645, :file "cljs/core.cljs"}, :name cljs.core/pr-str*, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 645, :end-line 645, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :test true}, eduction {:protocol-inline nil, :meta {:arglists (quote ([xform coll])), :doc "Returns a reducible/iterable/seqable application of\n  the transducer to the items in coll. Note that these applications\t\n  will be performed every time iterator/seq/reduce is called.", :end-column 15, :end-line 8928, :column 7, :line 8928, :file "cljs/core.cljs"}, :name cljs.core/eduction, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8928, :end-line 8928, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :doc "Returns a reducible/iterable/seqable application of\n  the transducer to the items in coll. Note that these applications\t\n  will be performed every time iterator/seq/reduce is called.", :test true}, tree-seq {:protocol-inline nil, :meta {:arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :end-column 15, :end-line 4282, :column 7, :line 4282, :file "cljs/core.cljs"}, :name cljs.core/tree-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 4282, :end-line 4282, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :test true}, unchecked-remainder-int {:protocol-inline nil, :meta {:arglists (quote ([x n])), :end-column 30, :end-line 2276, :column 7, :line 2276, :file "cljs/core.cljs"}, :name cljs.core/unchecked-remainder-int, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 2276, :end-line 2276, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :test true}, seq {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :tag seq, :end-column 15, :end-line 930, :column 12, :line 930, :file "cljs/core.cljs"}, :name cljs.core/seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 930, :ret-tag seq, :end-line 930, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :test true}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3884, :record false, :end-line 3884, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :end-column 13, :end-line 2012, :column 7, :line 2012, :file "cljs/core.cljs"}, :name cljs.core/reduce, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 2012, :end-line 2012, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :test true}, INIT {:meta {:end-column 10, :end-line 3377, :column 6, :line 3377, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 3377, :column 1, :end-line 3377, :end-column 10, :test true, :name cljs.core/INIT}, contains? {:protocol-inline nil, :meta {:arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :tag boolean, :end-column 25, :end-line 1875, :column 16, :line 1875, :file "cljs/core.cljs"}, :name cljs.core/contains?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 1875, :ret-tag boolean, :end-line 1875, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :test true}, every? {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :tag boolean, :end-column 22, :end-line 3579, :column 16, :line 3579, :file "cljs/core.cljs"}, :name cljs.core/every?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3579, :ret-tag boolean, :end-line 3579, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :test true}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:arglists (quote ([value iter _rest])), :factory :positional, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :end-column 24, :end-line 1021, :column 10, :line 1021, :file "cljs/core.cljs"}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6IteratorSeq, :variadic false, :max-fixed-arity 3}), :line 1021, :end-line 1021, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :test true}, Var {:num-fields 3, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 859, :record false, :end-line 859, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}}, keep-indexed {:protocol-inline nil, :meta {:arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :end-column 19, :end-line 3906, :column 7, :line 3906, :file "cljs/core.cljs"}, :name cljs.core/keep-indexed, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3906, :end-line 3906, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :test true}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:arglists (quote ([meta front rear __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :end-column 28, :end-line 5182, :column 10, :line 5182, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueueSeq, :variadic false, :max-fixed-arity 4}), :line 5182, :end-line 5182, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :test true}, subs {:protocol-inline nil, :meta {:arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :end-column 11, :end-line 2472, :column 7, :line 2472, :file "cljs/core.cljs"}, :name cljs.core/subs, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 2472, :end-line 2472, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :test true}, set {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll.", :end-column 10, :end-line 7885, :column 7, :line 7885, :file "cljs/core.cljs"}, :name cljs.core/set, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7885, :end-line 7885, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll.", :test true}, compare-indexed {:protocol-inline nil, :meta {:arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :private true, :end-column 32, :end-line 1933, :column 17, :line 1933, :file "cljs/core.cljs"}, :private true, :name cljs.core/compare-indexed, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag number, :variadic false, :max-fixed-arity 4}), :line 1933, :end-line 1933, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :test true}, take-last {:protocol-inline nil, :meta {:arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :end-column 16, :end-line 4120, :column 7, :line 4120, :file "cljs/core.cljs"}, :name cljs.core/take-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 4120, :end-line 4120, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :test true}, IndexedSeq {:meta {:declared true, :end-column 39, :end-line 913, :column 29, :line 913, :file "cljs/core.cljs"}, :num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1243, :record false, :declared true, :end-line 1243, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, bit-set {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Set bit at index n", :end-column 14, :end-line 2387, :column 7, :line 2387, :file "cljs/core.cljs"}, :name cljs.core/bit-set, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2387, :end-line 2387, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n", :test true}, string-hash-cache-count {:meta {:end-column 29, :end-line 724, :column 6, :line 724, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 724, :column 1, :end-line 724, :end-column 29, :test true, :name cljs.core/string-hash-cache-count}, ->Eduction {:protocol-inline nil, :meta {:arglists (quote ([xform coll])), :factory :positional, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :end-column 18, :end-line 8913, :column 10, :line 8913, :file "cljs/core.cljs"}, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8913, :end-line 8913, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :test true}, tree-map-add {:protocol-inline nil, :meta {:arglists (quote ([comp tree k v found])), :private true, :end-column 20, :end-line 7172, :column 8, :line 7172, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-add, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 5}), :line 7172, :end-line 7172, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found])), :test true}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:arglists (quote ([s])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 31, :end-line 5473, :column 10, :line 5473, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5473, :end-line 5473, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, -with-meta {:protocol-inline nil, :meta {:arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it.", :protocol cljs.core/IWithMeta, :tag clj, :end-column 19, :end-line 454, :column 9, :line 454, :file "cljs/core.cljs"}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 452, :ret-tag clj, :end-line 454, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it.", :test true}, reset-cache {:protocol-inline nil, :meta {:arglists (quote ([method-cache method-table cached-hierarchy hierarchy])), :private true, :end-column 19, :end-line 9186, :column 8, :line 9186, :file "cljs/core.cljs"}, :private true, :name cljs.core/reset-cache, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 9186, :end-line 9186, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy])), :test true}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:arglists (quote ([arr i cnt])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 36, :end-line 5623, :column 10, :line 5623, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapIterator, :variadic false, :max-fixed-arity 3}), :line 5623, :end-line 5623, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil, :test true}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 5623, :record false, :end-line 5623, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time", :end-column 14, :end-line 7962, :column 7, :line 7962, :file "cljs/core.cljs"}, :name cljs.core/butlast, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 7962, :end-line 7962, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time", :test true}, tail-off {:protocol-inline nil, :meta {:arglists (quote ([pv])), :private true, :end-column 16, :end-line 4455, :column 8, :line 4455, :file "cljs/core.cljs"}, :private true, :name cljs.core/tail-off, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 4455, :end-line 4455, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, unchecked-subtract-int {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :tag number, :end-column 37, :end-line 2286, :column 15, :line 2286, :file "cljs/core.cljs"}, :name cljs.core/unchecked-subtract-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2286, :ret-tag number, :end-line 2286, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -iterator {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns an iterator for coll.", :protocol cljs.core/IIterable, :end-column 13, :end-line 635, :column 4, :line 635, :file "cljs/core.cljs"}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 633, :end-line 635, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll.", :test true}, take-nth {:protocol-inline nil, :meta {:arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :end-column 15, :end-line 8212, :column 7, :line 8212, :file "cljs/core.cljs"}, :name cljs.core/take-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8212, :end-line 8212, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :test true}, first {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :end-column 12, :end-line 953, :column 7, :line 953, :file "cljs/core.cljs"}, :name cljs.core/first, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 953, :end-line 953, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :test true}, native-satisfies? {:protocol-inline nil, :meta {:arglists (quote ([p x])), :doc "Internal - do not use!", :tag boolean, :end-column 33, :end-line 186, :column 16, :line 186, :file "cljs/core.cljs"}, :name cljs.core/native-satisfies?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 186, :ret-tag boolean, :end-line 186, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!", :test true}, seq? {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Return true if s satisfies ISeq", :tag boolean, :end-column 20, :end-line 1845, :column 16, :line 1845, :file "cljs/core.cljs"}, :name cljs.core/seq?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1845, :ret-tag boolean, :end-line 1845, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq", :test true}, -global-hierarchy {:meta {:private true, :end-column 33, :end-line 9076, :column 16, :line 9076, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 9076, :column 1, :end-line 9076, :end-column 33, :private true, :test true, :name cljs.core/-global-hierarchy}, UUID {:num-fields 1, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 9466, :record false, :end-line 9466, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :protocol cljs.core/ISorted, :tag clj, :end-column 25, :end-line 506, :column 9, :line 506, :file "cljs/core.cljs"}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 501, :ret-tag clj, :end-line 506, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :test true}, println-str {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "println to a string, returning it", :end-column 18, :end-line 8624, :column 7, :line 8624, :file "cljs/core.cljs"}, :name cljs.core/println-str, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic true, :max-fixed-arity 0}), :line 8624, :end-line 8624, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "println to a string, returning it", :test true}, linear-traversal-nth {:protocol-inline nil, :meta {:arglists (quote ([coll n] [coll n not-found])), :private true, :end-column 28, :end-line 1470, :column 8, :line 1470, :file "cljs/core.cljs"}, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1470, :end-line 1470, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :test true}, iterate {:protocol-inline nil, :meta {:arglists (quote ([f x])), :added "1.0", :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :end-column 14, :end-line 4181, :column 7, :line 4181, :file "cljs/core.cljs"}, :added "1.0", :name cljs.core/iterate, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 4181, :end-line 4181, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :test true}, -empty {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count.", :protocol cljs.core/IEmptyableCollection, :end-column 10, :end-line 349, :column 4, :line 349, :file "cljs/core.cljs"}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 347, :end-line 349, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count.", :test true}, newline {:protocol-inline nil, :meta {:arglists (quote ([opts])), :end-column 14, :end-line 8582, :column 7, :line 8582, :file "cljs/core.cljs"}, :name cljs.core/newline, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8582, :end-line 8582, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :test true}, ILookup {:meta {:protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :protocol-symbol true, :doc "Protocol for looking up a value in a data structure.", :end-column 21, :end-line 391, :column 14, :line 391, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column 1, :line 391, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 391, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure.", :test true}, -chunked-rest {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed.", :protocol cljs.core/IChunkedSeq, :end-column 17, :end-line 599, :column 4, :line 599, :file "cljs/core.cljs"}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 595, :end-line 599, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed.", :test true}, write-all {:protocol-inline nil, :meta {:arglists (quote ([writer & ss])), :end-column 16, :end-line 8439, :column 7, :line 8439, :file "cljs/core.cljs"}, :name cljs.core/write-all, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([writer ss]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 1}), :line 8439, :end-line 8439, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer & ss])), :test true}, t4962 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t4962, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, fn? {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :tag boolean, :end-column 19, :end-line 1635, :column 16, :line 1635, :file "cljs/core.cljs"}, :name cljs.core/fn?, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean any}, :variadic false, :max-fixed-arity 1}), :line 1635, :ret-tag boolean, :end-line 1635, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :test true}, -prefer-method {:protocol-inline nil, :meta {:arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 18, :end-line 9242, :column 4, :line 9242, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9238, :end-line 9242, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil, :test true}, -assoc {:protocol-inline nil, :meta {:arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :protocol cljs.core/IAssociative, :tag clj, :end-column 15, :end-line 402, :column 9, :line 402, :file "cljs/core.cljs"}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 397, :ret-tag clj, :end-line 402, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :test true}, doall {:protocol-inline nil, :meta {:arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :end-column 12, :end-line 8349, :column 7, :line 8349, :file "cljs/core.cljs"}, :name cljs.core/doall, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 8349, :end-line 8349, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :test true}, keyword-identical? {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical.", :tag boolean, :end-column 34, :end-line 2800, :column 16, :line 2800, :file "cljs/core.cljs"}, :name cljs.core/keyword-identical?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2800, :ret-tag boolean, :end-line 2800, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical.", :test true}, pv-aset {:protocol-inline nil, :meta {:arglists (quote ([node idx val])), :private true, :end-column 15, :end-line 4449, :column 8, :line 4449, :file "cljs/core.cljs"}, :private true, :name cljs.core/pv-aset, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 4449, :end-line 4449, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val])), :test true}, prefers {:protocol-inline nil, :meta {:arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values", :end-column 14, :end-line 9460, :column 7, :line 9460, :file "cljs/core.cljs"}, :name cljs.core/prefers, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9460, :end-line 9460, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values", :test true}, -js->clj {:protocol-inline nil, :meta {:arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure", :protocol cljs.core/IEncodeClojure, :end-column 12, :end-line 8980, :column 4, :line 8980, :file "cljs/core.cljs"}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8979, :end-line 8980, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure", :test true}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2832, :record false, :end-line 2832, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :meta {:arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :end-column 13, :end-line 8886, :column 7, :line 8886, :file "cljs/core.cljs"}, :name cljs.core/dedupe, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag any, :variadic false, :max-fixed-arity 1}), :line 8886, :end-line 8886, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :test true}, unchecked-editable-array-for {:protocol-inline nil, :meta {:arglists (quote ([tv i])), :private true, :end-column 36, :end-line 5033, :column 8, :line 5033, :file "cljs/core.cljs"}, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 5033, :end-line 5033, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i])), :test true}, ->ES6Iterator {:protocol-inline nil, :meta {:arglists (quote ([s])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 21, :end-line 1005, :column 10, :line 1005, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 1005, :end-line 1005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4441, :record false, :end-line 4441, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :end-column 13, :end-line 1621, :column 7, :line 1621, :file "cljs/core.cljs"}, :name cljs.core/dissoc, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1621, :end-line 1621, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :test true}, atom {:meta {:declared true, :end-column 72, :end-line 5893, :column 68, :line 5893, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 5893, :column 1, :end-line 5893, :end-column 72, :declared true, :test true, :name cljs.core/atom}, bit-shift-right {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Bitwise shift right", :end-column 22, :end-line 2401, :column 7, :line 2401, :file "cljs/core.cljs"}, :name cljs.core/bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2401, :end-line 2401, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right", :test true}, *clojurescript-version* {:meta {:end-column 29, :end-line 16, :column 6, :line 16, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 16, :column 1, :end-line 16, :end-column 29, :test true, :name cljs.core/*clojurescript-version*}, -first {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :protocol cljs.core/ISeq, :end-column 10, :end-line 375, :column 4, :line 375, :file "cljs/core.cljs"}, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 373, :end-line 375, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :test true}, peek {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :end-column 11, :end-line 1709, :column 7, :line 1709, :file "cljs/core.cljs"}, :name cljs.core/peek, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1709, :end-line 1709, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :test true}, IKVReduce {:meta {:protocol-info {:methods {-kv-reduce [[coll f init]]}}, :protocol-symbol true, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :end-column 23, :end-line 465, :column 14, :line 465, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column 1, :line 465, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 465, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :test true}, aget {:protocol-inline nil, :meta {:arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :end-column 11, :end-line 269, :column 7, :line 269, :file "cljs/core.cljs"}, :name cljs.core/aget, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([array i] [array i idxs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 269, :end-line 269, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :test true}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 6766, :record false, :end-line 6766, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:arglists (quote ([writer s])), :doc "Writes s with writer and returns the result.", :protocol cljs.core/IWriter, :end-column 10, :end-line 520, :column 4, :line 520, :file "cljs/core.cljs"}, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 518, :end-line 520, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result.", :test true}, iter {:protocol-inline nil, :meta {:arglists (quote ([coll])), :end-column 11, :end-line 3401, :column 7, :line 3401, :file "cljs/core.cljs"}, :name cljs.core/iter, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/t20896 cljs.core/StringIter cljs.core/ArrayIter cljs.core/SeqIter}, :variadic false, :max-fixed-arity 1}), :line 3401, :end-line 3401, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, mk-bound-fn {:protocol-inline nil, :meta {:arglists (quote ([sc test key])), :end-column 18, :end-line 8066, :column 7, :line 8066, :file "cljs/core.cljs"}, :name cljs.core/mk-bound-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 3}), :line 8066, :end-line 8066, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key])), :test true}, last {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Return the last item in coll, in linear time", :end-column 11, :end-line 1410, :column 7, :line 1410, :file "cljs/core.cljs"}, :name cljs.core/last, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1410, :end-line 1410, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time", :test true}, pr {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :end-column 9, :end-line 8597, :column 7, :line 8597, :file "cljs/core.cljs"}, :name cljs.core/pr, :variadic true, :file "cljs/core.cljs", :end-column 9, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8597, :end-line 8597, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :test true}, tree-map-seq-push {:protocol-inline nil, :meta {:arglists (quote ([node stack ascending?])), :private true, :end-column 25, :end-line 6759, :column 8, :line 6759, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 6759, :end-line 6759, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?])), :test true}, namespace {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :end-column 16, :end-line 2810, :column 7, :line 2810, :file "cljs/core.cljs"}, :name cljs.core/namespace, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 1}), :line 2810, :end-line 2810, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :test true}, empty-unordered-hash {:meta {:private true, :end-column 36, :end-line 1079, :column 16, :line 1079, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 1079, :column 1, :end-line 1079, :end-column 36, :private true, :test true, :name cljs.core/empty-unordered-hash}, obj-map {:protocol-inline nil, :meta {:arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :end-column 14, :end-line 7444, :column 7, :line 7444, :file "cljs/core.cljs"}, :name cljs.core/obj-map, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7444, :end-line 7444, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :test true}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1126, :record false, :end-line 1126, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :meta {:arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :protocol cljs.core/ICollection, :tag clj, :end-column 14, :end-line 355, :column 9, :line 355, :file "cljs/core.cljs"}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 353, :ret-tag clj, :end-line 355, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :test true}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 6387, :record false, :end-line 6387, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :tag boolean, :end-column 17, :end-line 986, :column 16, :line 986, :file "cljs/core.cljs"}, :name cljs.core/=, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 986, :ret-tag boolean, :end-line 986, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :test true}, ITransientMap {:meta {:protocol-info {:methods {-dissoc! [[tcoll key]]}}, :protocol-symbol true, :doc "Protocol for adding mapping functionality to transient collections.", :end-column 27, :end-line 567, :column 14, :line 567, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column 1, :line 567, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 567, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections.", :test true}, push-tail {:protocol-inline nil, :meta {:arglists (quote ([pv level parent tailnode])), :private true, :end-column 17, :end-line 4471, :column 8, :line 4471, :file "cljs/core.cljs"}, :private true, :name cljs.core/push-tail, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 4}), :line 4471, :end-line 4471, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode])), :test true}, take {:protocol-inline nil, :meta {:arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :end-column 11, :end-line 4067, :column 7, :line 4067, :file "cljs/core.cljs"}, :name cljs.core/take, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4067, :end-line 4067, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :test true}, vector? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x satisfies IVector", :tag boolean, :end-column 23, :end-line 1781, :column 16, :line 1781, :file "cljs/core.cljs"}, :name cljs.core/vector?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1781, :ret-tag boolean, :end-line 1781, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector", :test true}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:arglists (quote ([bitmap bit])), :private true, :end-column 33, :end-line 5919, :column 8, :line 5919, :file "cljs/core.cljs"}, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5919, :end-line 5919, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit])), :test true}, boolean {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to boolean", :tag boolean, :end-column 23, :end-line 1857, :column 16, :line 1857, :file "cljs/core.cljs"}, :name cljs.core/boolean, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1857, :ret-tag boolean, :end-line 1857, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean", :test true}, t20893 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t20893, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, IChunk {:meta {:protocol-info {:methods {-drop-first [[coll]]}}, :protocol-symbol true, :doc "Protocol for accessing the items of a chunk.", :end-column 20, :end-line 590, :column 14, :line 590, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column 1, :line 590, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 590, :impls #{cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk.", :test true}, bit-shift-left {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Bitwise shift left", :end-column 21, :end-line 2397, :column 7, :line 2397, :file "cljs/core.cljs"}, :name cljs.core/bit-shift-left, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2397, :end-line 2397, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left", :test true}, rand-int {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :end-column 15, :end-line 9049, :column 7, :line 9049, :file "cljs/core.cljs"}, :name cljs.core/rand-int, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9049, :end-line 9049, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :test true}, aclone {:protocol-inline nil, :meta {:arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array", :end-column 13, :end-line 246, :column 7, :line 246, :file "cljs/core.cljs"}, :name cljs.core/aclone, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 246, :end-line 246, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array", :test true}, BlackNode {:meta {:declared true, :end-column 27, :end-line 6822, :column 18, :line 6822, :file "cljs/core.cljs"}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 6925, :record false, :declared true, :end-line 6925, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, vreset! {:protocol-inline nil, :meta {:arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :end-column 14, :end-line 3901, :column 7, :line 3901, :file "cljs/core.cljs"}, :name cljs.core/vreset!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 3901, :end-line 3901, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :test true}, chunk {:protocol-inline nil, :meta {:arglists (quote ([b])), :end-column 12, :end-line 3021, :column 7, :line 3021, :file "cljs/core.cljs"}, :name cljs.core/chunk, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3021, :end-line 3021, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b])), :test true}, dec {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns a number one less than num.", :end-column 10, :end-line 2179, :column 7, :line 2179, :file "cljs/core.cljs"}, :name cljs.core/dec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2179, :end-line 2179, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num.", :test true}, map {:protocol-inline nil, :meta {:arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :end-column 10, :end-line 4020, :column 7, :line 4020, :file "cljs/core.cljs"}, :name cljs.core/map, :variadic true, :file "cljs/core.cljs", :end-column 10, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 4}), :line 4020, :end-line 4020, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :test true}, juxt {:protocol-inline nil, :meta {:arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :end-column 11, :end-line 8300, :column 7, :line 8300, :file "cljs/core.cljs"}, :name cljs.core/juxt, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([f] [f g] [f g h] [f g h fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 8300, :end-line 8300, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :test true}, < {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :tag boolean, :end-column 17, :end-line 2131, :column 16, :line 2131, :file "cljs/core.cljs"}, :name cljs.core/<, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2131, :ret-tag boolean, :end-line 2131, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :test true}, inode-kv-reduce {:protocol-inline nil, :meta {:arglists (quote ([arr f init])), :private true, :end-column 23, :end-line 5936, :column 8, :line 5936, :file "cljs/core.cljs"}, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 5936, :end-line 5936, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init])), :test true}, obj-map->hash-map {:protocol-inline nil, :meta {:arglists (quote ([m k v])), :private true, :end-column 25, :end-line 5325, :column 8, :line 5325, :file "cljs/core.cljs"}, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5325, :end-line 5325, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, test {:protocol-inline nil, :meta {:arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :end-column 11, :end-line 9575, :column 7, :line 9575, :file "cljs/core.cljs"}, :name cljs.core/test, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 1}), :line 9575, :end-line 9575, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :test true}, rest {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :tag seq, :end-column 16, :end-line 964, :column 12, :line 964, :file "cljs/core.cljs"}, :name cljs.core/rest, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 964, :ret-tag seq, :end-line 964, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :test true}, ex-data {:protocol-inline nil, :meta {:arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :end-column 14, :end-line 9538, :column 7, :line 9538, :file "cljs/core.cljs"}, :name cljs.core/ex-data, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9538, :end-line 9538, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :test true}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5562, :record false, :end-line 5562, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed.", :protocol cljs.core/IChunk, :end-column 15, :end-line 592, :column 4, :line 592, :file "cljs/core.cljs"}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 590, :end-line 592, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed.", :test true}, isa? {:protocol-inline nil, :meta {:arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :tag boolean, :end-column 20, :end-line 9086, :column 16, :line 9086, :file "cljs/core.cljs"}, :name cljs.core/isa?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic false, :max-fixed-arity 3}), :line 9086, :ret-tag boolean, :end-line 9086, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :test true}, -clone {:protocol-inline nil, :meta {:arglists (quote ([value])), :doc "Creates a clone of value.", :protocol cljs.core/ICloneable, :tag clj, :end-column 15, :end-line 339, :column 9, :line 339, :file "cljs/core.cljs"}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 337, :ret-tag clj, :end-line 339, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value.", :test true}, empty-ordered-hash {:meta {:private true, :end-column 34, :end-line 1064, :column 16, :line 1064, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 1064, :column 1, :end-line 1064, :end-column 34, :private true, :test true, :name cljs.core/empty-ordered-hash}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1021, :record false, :end-line 1021, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:arglists (quote ([])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :end-column 20, :end-line 5280, :column 10, :line 5280, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NeverEquiv, :variadic false, :max-fixed-arity 0}), :line 5280, :end-line 5280, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}, :test true}, re-seq {:protocol-inline nil, :meta {:arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s.", :end-column 13, :end-line 8396, :column 7, :line 8396, :file "cljs/core.cljs"}, :name cljs.core/re-seq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8396, :end-line 8396, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s.", :test true}, make-hierarchy {:protocol-inline nil, :meta {:arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc.", :end-column 21, :end-line 9072, :column 7, :line 9072, :file "cljs/core.cljs"}, :name cljs.core/make-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 9072, :end-line 9072, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc.", :test true}, Symbol {:meta {:declared true, :end-column 21, :end-line 720, :column 15, :line 720, :file "cljs/core.cljs"}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 814, :record false, :declared true, :end-line 814, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, tv-push-tail {:protocol-inline nil, :meta {:arglists (quote ([tv level parent tail-node])), :private true, :end-column 20, :end-line 5007, :column 8, :line 5007, :file "cljs/core.cljs"}, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 4}), :line 5007, :end-line 5007, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node])), :test true}, -reduce {:protocol-inline nil, :meta {:arglists (quote ([coll f] [coll f start])), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :protocol cljs.core/IReduce, :end-column 11, :end-line 460, :column 4, :line 460, :file "cljs/core.cljs"}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 457, :end-line 460, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f] [coll f start])), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :test true}, -count {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :protocol cljs.core/ICounted, :tag number, :end-column 18, :end-line 344, :column 12, :line 344, :file "cljs/core.cljs"}, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 342, :ret-tag number, :end-line 344, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :test true}, keep {:protocol-inline nil, :meta {:arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :end-column 11, :end-line 3741, :column 7, :line 3741, :file "cljs/core.cljs"}, :name cljs.core/keep, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3741, :end-line 3741, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :test true}, char {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to char", :end-column 11, :end-line 2199, :column 7, :line 2199, :file "cljs/core.cljs"}, :name cljs.core/char, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 2199, :end-line 2199, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char", :test true}, mapcat {:protocol-inline nil, :meta {:arglists (quote ([f] [f & colls])), :static true, :added "1.0", :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :end-column 13, :end-line 4235, :column 7, :line 4235, :file "cljs/core.cljs"}, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "cljs/core.cljs", :end-column 13, :static true, :method-params ([f] [f colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 4235, :end-line 4235, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :test true}, unchecked-long {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-column 21, :end-line 2313, :column 7, :line 2313, :file "cljs/core.cljs"}, :name cljs.core/unchecked-long, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2313, :end-line 2313, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, m3-seed {:meta {:end-column 13, :end-line 678, :column 6, :line 678, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 678, :column 1, :end-line 678, :end-column 13, :test true, :name cljs.core/m3-seed}, some? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise.", :tag boolean, :end-column 21, :end-line 169, :column 16, :line 169, :file "cljs/core.cljs"}, :name cljs.core/some?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 169, :ret-tag boolean, :end-line 169, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise.", :test true}, unchecked-negate {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 23, :end-line 2268, :column 7, :line 2268, :file "cljs/core.cljs"}, :name cljs.core/unchecked-negate, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2268, :end-line 2268, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, reverse {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :end-column 14, :end-line 2666, :column 7, :line 2666, :file "cljs/core.cljs"}, :name cljs.core/reverse, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq any}, :variadic false, :max-fixed-arity 1}), :line 2666, :end-line 2666, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :test true}, range {:protocol-inline nil, :meta {:arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :end-column 12, :end-line 8203, :column 7, :line 8203, :file "cljs/core.cljs"}, :name cljs.core/range, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 0} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 3}), :line 8203, :end-line 8203, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :test true}, bit-count {:protocol-inline nil, :meta {:arglists (quote ([v])), :doc "Counts the number of bits set in n", :end-column 16, :end-line 2413, :column 7, :line 2413, :file "cljs/core.cljs"}, :name cljs.core/bit-count, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2413, :end-line 2413, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n", :test true}, create-node {:protocol-inline nil, :meta {:arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :private true, :end-column 19, :end-line 6369, :column 8, :line 6369, :file "cljs/core.cljs"}, :private true, :name cljs.core/create-node, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 6} {:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 7}), :line 6369, :end-line 6369, :max-fixed-arity 7, :fn-var true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :test true}, sort {:protocol-inline nil, :meta {:arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-column 11, :end-line 1964, :column 7, :line 1964, :file "cljs/core.cljs"}, :name cljs.core/sort, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2}), :line 1964, :end-line 1964, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ->MetaFn {:protocol-inline nil, :meta {:arglists (quote ([afn meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :end-column 16, :end-line 1640, :column 10, :line 1640, :file "cljs/core.cljs"}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MetaFn, :variadic false, :max-fixed-arity 2}), :line 1640, :end-line 1640, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :test true}, unchecked-inc-int {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 24, :end-line 2251, :column 7, :line 2251, :file "cljs/core.cljs"}, :name cljs.core/unchecked-inc-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2251, :end-line 2251, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -compare {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :protocol cljs.core/IComparable, :tag number, :end-column 20, :end-line 586, :column 12, :line 586, :file "cljs/core.cljs"}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 584, :ret-tag number, :end-line 586, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :test true}, map-indexed {:protocol-inline nil, :meta {:arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :end-column 18, :end-line 3714, :column 7, :line 3714, :file "cljs/core.cljs"}, :name cljs.core/map-indexed, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3714, :end-line 3714, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :test true}, array-list {:protocol-inline nil, :meta {:arglists (quote ([])), :end-column 17, :end-line 8013, :column 7, :line 8013, :file "cljs/core.cljs"}, :name cljs.core/array-list, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 0}), :line 8013, :end-line 8013, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, rand-nth {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :end-column 15, :end-line 9053, :column 7, :line 9053, :file "cljs/core.cljs"}, :name cljs.core/rand-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9053, :end-line 9053, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :test true}, comp {:protocol-inline nil, :meta {:arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :end-column 11, :end-line 3631, :column 7, :line 3631, :file "cljs/core.cljs"}, :name cljs.core/comp, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([] [f] [f g] [f g h] [f1 f2 f3 fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3631, :end-line 3631, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :test true}, array-chunk {:protocol-inline nil, :meta {:arglists (quote ([arr] [arr off] [arr off end])), :end-column 18, :end-line 2941, :column 7, :line 2941, :file "cljs/core.cljs"}, :name cljs.core/array-chunk, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 1} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2941, :end-line 2941, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr] [arr off] [arr off end])), :test true}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill", :end-column 32, :end-line 2405, :column 7, :line 2405, :file "cljs/core.cljs"}, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2405, :end-line 2405, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill", :test true}, -as-transient {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :protocol cljs.core/IEditableCollection, :tag clj, :end-column 22, :end-line 551, :column 9, :line 551, :file "cljs/core.cljs"}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 549, :ret-tag clj, :end-line 551, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :test true}, dorun {:protocol-inline nil, :meta {:arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :end-column 12, :end-line 8336, :column 7, :line 8336, :file "cljs/core.cljs"}, :name cljs.core/dorun, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1} {:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8336, :end-line 8336, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :test true}, pr-sequential-writer {:protocol-inline nil, :meta {:arglists (quote ([writer print-one begin sep end opts coll])), :end-column 27, :end-line 8416, :column 7, :line 8416, :file "cljs/core.cljs"}, :name cljs.core/pr-sequential-writer, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 7}), :line 8416, :end-line 8416, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll])), :test true}, accumulating-seq-count {:protocol-inline nil, :meta {:arglists (quote ([coll])), :private true, :end-column 30, :end-line 1443, :column 8, :line 1443, :file "cljs/core.cljs"}, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1443, :end-line 1443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IIndexed {:meta {:protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :protocol-symbol true, :doc "Protocol for collections to provide idexed-based access to their items.", :end-column 22, :end-line 364, :column 14, :line 364, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column 1, :line 364, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 364, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide idexed-based access to their items.", :test true}, disj {:protocol-inline nil, :meta {:arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-column 11, :end-line 1724, :column 7, :line 1724, :file "cljs/core.cljs"}, :name cljs.core/disj, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1724, :end-line 1724, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, IPrintWithWriter {:meta {:protocol-info {:methods {-pr-writer [[o writer opts]]}}, :protocol-symbol true, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :end-column 30, :end-line 525, :column 14, :line 525, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column 1, :line 525, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 525, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :test true}, ->UUID {:protocol-inline nil, :meta {:arglists (quote ([uuid])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :end-column 14, :end-line 9466, :column 10, :line 9466, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/->UUID, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/UUID, :variadic false, :max-fixed-arity 1}), :line 9466, :end-line 9466, :max-fixed-arity 1, :fn-var true, :arglists (quote ([uuid])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :test true}, IVector {:meta {:protocol-info {:methods {-assoc-n [[coll n val]]}}, :protocol-symbol true, :doc "Protocol for adding vector functionality to collections.", :end-column 21, :end-line 434, :column 14, :line 434, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column 1, :line 434, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 434, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections.", :test true}, IIterable {:meta {:protocol-info {:methods {-iterator [[coll]]}}, :protocol-symbol true, :doc "Protocol for iterating over a collection.", :end-column 23, :end-line 633, :column 14, :line 633, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column 1, :line 633, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 633, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}, :doc "Protocol for iterating over a collection.", :test true}, *2 {:meta {:doc "bound in a repl thread to the second most recent value printed", :end-column 5, :end-line 124, :column 3, :line 124, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 122, :column 1, :end-line 124, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :test true, :name cljs.core/*2}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 8913, :record false, :end-line 8913, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:arglists (quote ([node])), :private true, :end-column 21, :end-line 4452, :column 8, :line 4452, :file "cljs/core.cljs"}, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4452, :end-line 4452, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, cons {:protocol-inline nil, :meta {:arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest.", :end-column 11, :end-line 2739, :column 7, :line 2739, :file "cljs/core.cljs"}, :name cljs.core/cons, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 2739, :end-line 2739, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest.", :test true}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7786, :record false, :end-line 7786, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, floats {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 13, :end-line 2323, :column 7, :line 2323, :file "cljs/core.cljs"}, :name cljs.core/floats, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2323, :end-line 2323, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, TransientVector {:meta {:declared true, :end-column 59, :end-line 4557, :column 44, :line 4557, :file "cljs/core.cljs"}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5049, :record false, :declared true, :end-line 5049, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, pos? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false", :tag boolean, :end-column 20, :end-line 2433, :column 16, :line 2433, :file "cljs/core.cljs"}, :name cljs.core/pos?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2433, :ret-tag boolean, :end-line 2433, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false", :test true}, fnil {:protocol-inline nil, :meta {:arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :end-column 11, :end-line 3689, :column 7, :line 3689, :file "cljs/core.cljs"}, :name cljs.core/fnil, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4}), :line 3689, :end-line 3689, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :test true}, merge-with {:protocol-inline nil, :meta {:arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :end-column 17, :end-line 7620, :column 7, :line 7620, :file "cljs/core.cljs"}, :name cljs.core/merge-with, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([f maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic true, :max-fixed-arity 1}), :line 7620, :end-line 7620, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :test true}, nthrest {:protocol-inline nil, :meta {:arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0.", :end-column 14, :end-line 1554, :column 7, :line 1554, :file "cljs/core.cljs"}, :name cljs.core/nthrest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1554, :end-line 1554, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0.", :test true}, sequential? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential", :tag boolean, :end-column 27, :end-line 1762, :column 16, :line 1762, :file "cljs/core.cljs"}, :name cljs.core/sequential?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1762, :ret-tag boolean, :end-line 1762, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential", :test true}, tree-map-replace {:protocol-inline nil, :meta {:arglists (quote ([comp tree k v])), :private true, :end-column 24, :end-line 7270, :column 8, :line 7270, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 7270, :end-line 7270, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v])), :test true}, m3-mix-H1 {:protocol-inline nil, :meta {:arglists (quote ([h1 k1])), :tag number, :end-column 24, :end-line 685, :column 15, :line 685, :file "cljs/core.cljs"}, :name cljs.core/m3-mix-H1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 685, :ret-tag number, :end-line 685, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1])), :test true}, ->TransientArrayMap {:protocol-inline nil, :meta {:arglists (quote ([editable? len arr])), :factory :positional, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :end-column 27, :end-line 5812, :column 10, :line 5812, :file "cljs/core.cljs"}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientArrayMap, :variadic false, :max-fixed-arity 3}), :line 5812, :end-line 5812, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, prim-seq {:protocol-inline nil, :meta {:arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :end-column 15, :end-line 1313, :column 7, :line 1313, :file "cljs/core.cljs"}, :name cljs.core/prim-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1313, :end-line 1313, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :test true}, *print-level* {:meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :dynamic true, :end-column 16, :end-line 97, :column 3, :line 97, :file "cljs/core.cljs"}, :name cljs.core/*print-level*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 87, :end-line 97, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :test true}, shuffle {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Return a random permutation of coll", :end-column 14, :end-line 2005, :column 7, :line 2005, :file "cljs/core.cljs"}, :name cljs.core/shuffle, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2005, :end-line 2005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll", :test true}, ChunkedSeq {:meta {:declared true, :end-column 32, :end-line 1785, :column 22, :line 1785, :file "cljs/core.cljs"}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4782, :record false, :declared true, :end-line 4782, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, hash-keyword {:protocol-inline nil, :meta {:arglists (quote ([k])), :end-column 19, :end-line 2752, :column 7, :line 2752, :file "cljs/core.cljs"}, :name cljs.core/hash-keyword, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2752, :end-line 2752, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, find {:protocol-inline nil, :meta {:arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present.", :end-column 11, :end-line 1886, :column 7, :line 1886, :file "cljs/core.cljs"}, :name cljs.core/find, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1886, :end-line 1886, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present.", :test true}, alength {:protocol-inline nil, :meta {:arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types.", :tag number, :end-column 22, :end-line 283, :column 15, :line 283, :file "cljs/core.cljs"}, :name cljs.core/alength, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 283, :ret-tag number, :end-line 283, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types.", :test true}, bit-xor {:protocol-inline nil, :meta {:arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :end-column 14, :end-line 2349, :column 7, :line 2349, :file "cljs/core.cljs"}, :name cljs.core/bit-xor, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2349, :end-line 2349, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :test true}, ->IndexedSeq {:protocol-inline nil, :meta {:arglists (quote ([arr i])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :end-column 20, :end-line 1243, :column 10, :line 1243, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeq, :variadic false, :max-fixed-arity 2}), :line 1243, :end-line 1243, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5349, :record false, :end-line 5349, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Bitwise shift right with zero fill", :end-column 31, :end-line 2409, :column 7, :line 2409, :file "cljs/core.cljs"}, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2409, :end-line 2409, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill", :test true}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5473, :record false, :end-line 5473, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if num is less than zero, else false", :tag boolean, :end-column 20, :end-line 2442, :column 16, :line 2442, :file "cljs/core.cljs"}, :name cljs.core/neg?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2442, :ret-tag boolean, :end-line 2442, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false", :test true}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2690, :record false, :end-line 2690, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:arglists (quote ([mf dispatch-val])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 18, :end-line 9241, :column 4, :line 9241, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9238, :end-line 9241, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil, :test true}, ->StringIter {:protocol-inline nil, :meta {:arglists (quote ([s i])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 20, :end-line 3353, :column 10, :line 3353, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 2}), :line 3353, :end-line 3353, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil, :test true}, js-invoke {:protocol-inline nil, :meta {:arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :end-column 16, :end-line 298, :column 7, :line 298, :file "cljs/core.cljs"}, :name cljs.core/js-invoke, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([obj s args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 2}), :line 298, :end-line 298, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :test true}, ->List {:protocol-inline nil, :meta {:arglists (quote ([meta first rest count __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 14, :end-line 2538, :column 10, :line 2538, :file "cljs/core.cljs"}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/List, :variadic false, :max-fixed-arity 5}), :line 2538, :end-line 2538, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, m3-mix-K1 {:protocol-inline nil, :meta {:arglists (quote ([k1])), :tag number, :end-column 24, :end-line 682, :column 15, :line 682, :file "cljs/core.cljs"}, :name cljs.core/m3-mix-K1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 682, :ret-tag number, :end-line 682, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1])), :test true}, unchecked-float {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 30, :end-line 2214, :column 15, :line 2214, :file "cljs/core.cljs"}, :name cljs.core/unchecked-float, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2214, :ret-tag number, :end-line 2214, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, t7430 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7430, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, undefined? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value.", :tag boolean, :end-column 26, :end-line 1840, :column 16, :line 1840, :file "cljs/core.cljs"}, :name cljs.core/undefined?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1840, :ret-tag boolean, :end-line 1840, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value.", :test true}, IMeta {:meta {:protocol-info {:methods {-meta [[o]]}}, :protocol-symbol true, :doc "Protocol for accessing the metadata of an object.", :end-column 19, :end-line 447, :column 14, :line 447, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column 1, :line 447, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 447, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/t20893 cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/t20896 cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object.", :test true}, reduced? {:protocol-inline nil, :meta {:arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced", :tag boolean, :end-column 24, :end-line 1135, :column 16, :line 1135, :file "cljs/core.cljs"}, :name cljs.core/reduced?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1135, :ret-tag boolean, :end-line 1135, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced", :test true}, apply-to {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([f argc args]))}, :name cljs.core/apply-to, :variadic false, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 3268, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args])), :test true}, disj! {:protocol-inline nil, :meta {:arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-column 12, :end-line 3253, :column 7, :line 3253, :file "cljs/core.cljs"}, :name cljs.core/disj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 3253, :end-line 3253, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, -lookup {:protocol-inline nil, :meta {:arglists (quote ([o k] [o k not-found])), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :protocol cljs.core/ILookup, :end-column 11, :end-line 393, :column 4, :line 393, :file "cljs/core.cljs"}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 391, :end-line 393, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :test true}, ICloneable {:meta {:protocol-info {:methods {-clone [[value]]}}, :protocol-symbol true, :doc "Protocol for cloning a value.", :end-column 24, :end-line 337, :column 14, :line 337, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 337, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 337, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value.", :test true}, IEncodeClojure {:meta {:protocol-info {:methods {-js->clj [[x options]]}}, :protocol-symbol true, :doc nil, :end-column 28, :end-line 8979, :column 14, :line 8979, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column 1, :line 8979, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 8979, :impls #{}, :doc nil, :test true}, booleans {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 15, :end-line 2318, :column 7, :line 2318, :file "cljs/core.cljs"}, :name cljs.core/booleans, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2318, :end-line 2318, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, array-map-index-of-symbol? {:protocol-inline nil, :meta {:arglists (quote ([arr m k])), :private true, :end-column 34, :end-line 5506, :column 8, :line 5506, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5506, :end-line 5506, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ->ArrayList {:protocol-inline nil, :meta {:arglists (quote ([arr])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 19, :end-line 8005, :column 10, :line 8005, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 1}), :line 8005, :end-line 8005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil, :test true}, RSeq {:meta {:declared true, :end-column 29, :end-line 1224, :column 25, :line 1224, :file "cljs/core.cljs"}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1330, :record false, :declared true, :end-line 1330, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, mask {:protocol-inline nil, :meta {:arglists (quote ([hash shift])), :private true, :end-column 12, :end-line 5901, :column 8, :line 5901, :file "cljs/core.cljs"}, :private true, :name cljs.core/mask, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5901, :end-line 5901, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, int-array {:protocol-inline nil, :meta {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :end-column 16, :end-line 3058, :column 7, :line 3058, :file "cljs/core.cljs"}, :name cljs.core/int-array, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 3058, :end-line 3058, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :test true}, find-and-cache-best-method {:protocol-inline nil, :meta {:arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :private true, :end-column 34, :end-line 9213, :column 8, :line 9213, :file "cljs/core.cljs"}, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 7}), :line 9213, :end-line 9213, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :test true}, set? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x satisfies ISet", :tag boolean, :end-column 20, :end-line 1751, :column 16, :line 1751, :file "cljs/core.cljs"}, :name cljs.core/set?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1751, :ret-tag boolean, :end-line 1751, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet", :test true}, iterable? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x implements IIterable protocol.", :end-column 16, :end-line 915, :column 7, :line 915, :file "cljs/core.cljs"}, :name cljs.core/iterable?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 915, :end-line 915, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol.", :test true}, cat {:protocol-inline nil, :meta {:arglists (quote ([rf])), :added "1.7", :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :end-column 10, :end-line 8874, :column 7, :line 8874, :file "cljs/core.cljs"}, :added "1.7", :name cljs.core/cat, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8874, :end-line 8874, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :test true}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:arglists (quote ([s])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 28, :end-line 5460, :column 10, :line 5460, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5460, :end-line 5460, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, divide {:meta {:declared true, :end-column 16, :end-line 2122, :column 10, :line 2122, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 2122, :column 1, :end-line 2122, :end-column 16, :declared true, :test true, :name cljs.core/divide}, -pr-writer {:protocol-inline nil, :meta {:arglists (quote ([o writer opts])), :doc nil, :protocol cljs.core/IPrintWithWriter, :end-column 14, :end-line 531, :column 4, :line 531, :file "cljs/core.cljs"}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 525, :end-line 531, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil, :test true}, flush {:protocol-inline nil, :meta {:arglists (quote ([])), :end-column 12, :end-line 8447, :column 7, :line 8447, :file "cljs/core.cljs"}, :name cljs.core/flush, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 0}), :line 8447, :end-line 8447, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, set-from-indexed-seq {:protocol-inline nil, :meta {:arglists (quote ([iseq])), :end-column 27, :end-line 7879, :column 7, :line 7879, :file "cljs/core.cljs"}, :name cljs.core/set-from-indexed-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7879, :end-line 7879, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq])), :test true}, take-while {:protocol-inline nil, :meta {:arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-column 17, :end-line 8047, :column 7, :line 8047, :file "cljs/core.cljs"}, :name cljs.core/take-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8047, :end-line 8047, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, vary-meta {:protocol-inline nil, :meta {:arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :end-column 16, :end-line 3319, :column 7, :line 3319, :file "cljs/core.cljs"}, :name cljs.core/vary-meta, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 5} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 6} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 6}), :line 3319, :end-line 3319, :max-fixed-arity 6, :fn-var true, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :test true}, INext {:meta {:protocol-info {:methods {-next [[coll]]}}, :protocol-symbol true, :doc "Protocol for accessing the next items of a collection.", :end-column 19, :end-line 383, :column 14, :line 383, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column 1, :line 383, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 383, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :doc "Protocol for accessing the next items of a collection.", :test true}, is_proto_ {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 16, :end-line 196, :column 7, :line 196, :file "cljs/core.cljs"}, :name cljs.core/is_proto_, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 196, :end-line 196, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, START {:meta {:end-column 11, :end-line 3378, :column 6, :line 3378, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 3378, :column 1, :end-line 3378, :end-column 11, :test true, :name cljs.core/START}, ICounted {:meta {:protocol-info {:methods {-count [[coll]]}}, :protocol-symbol true, :doc "Protocol for adding the ability to count a collection in constant time.", :end-column 22, :end-line 342, :column 14, :line 342, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column 1, :line 342, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 342, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time.", :test true}, IMapEntry {:meta {:protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :protocol-symbol true, :doc "Protocol for examining a map entry.", :end-column 23, :end-line 412, :column 14, :line 412, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column 1, :line 412, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 412, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for examining a map entry.", :test true}, <= {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :tag boolean, :end-column 18, :end-line 2143, :column 16, :line 2143, :file "cljs/core.cljs"}, :name cljs.core/<=, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2143, :ret-tag boolean, :end-line 2143, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :test true}, conj! {:protocol-inline nil, :meta {:arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :end-column 12, :end-line 3212, :column 7, :line 3212, :file "cljs/core.cljs"}, :name cljs.core/conj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([] [coll] [tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 3212, :end-line 3212, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :test true}, -pop {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :protocol cljs.core/IStack, :tag clj, :end-column 13, :end-line 430, :column 9, :line 430, :file "cljs/core.cljs"}, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 424, :ret-tag clj, :end-line 430, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :test true}, repeatedly {:protocol-inline nil, :meta {:arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :end-column 17, :end-line 4174, :column 7, :line 4174, :file "cljs/core.cljs"}, :name cljs.core/repeatedly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4174, :end-line 4174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :test true}, zipmap {:protocol-inline nil, :meta {:arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals.", :end-column 13, :end-line 7979, :column 7, :line 7979, :file "cljs/core.cljs"}, :name cljs.core/zipmap, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 7979, :end-line 7979, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals.", :test true}, IStack {:meta {:protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :protocol-symbol true, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :end-column 20, :end-line 424, :column 14, :line 424, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column 1, :line 424, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 424, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :test true}, -remove-watch {:protocol-inline nil, :meta {:arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this.", :protocol cljs.core/IWatchable, :end-column 17, :end-line 546, :column 4, :line 546, :file "cljs/core.cljs"}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 539, :end-line 546, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this.", :test true}, IVolatile {:meta {:protocol-info {:methods {-vreset! [[o new-value]]}}, :protocol-symbol true, :doc "Protocol for adding volatile functionality.", :end-column 23, :end-line 627, :column 14, :line 627, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column 1, :line 627, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 627, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality.", :test true}, remove {:protocol-inline nil, :meta {:arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-column 13, :end-line 4274, :column 7, :line 4274, :file "cljs/core.cljs"}, :name cljs.core/remove, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4274, :end-line 4274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:arglists (quote ([edit bitmap arr])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 27, :end-line 5954, :column 10, :line 5954, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5954, :end-line 5954, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil, :test true}, * {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :tag number, :end-column 16, :end-line 2115, :column 15, :line 2115, :file "cljs/core.cljs"}, :name cljs.core/*, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2115, :ret-tag number, :end-line 2115, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, re-pattern {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string.", :end-column 17, :end-line 8405, :column 7, :line 8405, :file "cljs/core.cljs"}, :name cljs.core/re-pattern, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil js/RegExp}, :variadic false, :max-fixed-arity 1}), :line 8405, :end-line 8405, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string.", :test true}, min {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :tag number, :end-column 18, :end-line 2190, :column 15, :line 2190, :file "cljs/core.cljs"}, :name cljs.core/min, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2190, :ret-tag number, :end-line 2190, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :test true}, array-map-index-of-nil? {:protocol-inline nil, :meta {:arglists (quote ([arr m k])), :private true, :end-column 31, :end-line 5487, :column 8, :line 5487, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of-nil?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5487, :end-line 5487, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -persistent! {:protocol-inline nil, :meta {:arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it.", :protocol cljs.core/ITransientCollection, :tag clj, :end-column 21, :end-line 558, :column 9, :line 558, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 554, :ret-tag clj, :end-line 558, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it.", :test true}, -nth {:protocol-inline nil, :meta {:arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :protocol cljs.core/IIndexed, :end-column 8, :end-line 366, :column 4, :line 366, :file "cljs/core.cljs"}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 364, :end-line 366, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :test true}, pop! {:protocol-inline nil, :meta {:arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :end-column 11, :end-line 3247, :column 7, :line 3247, :file "cljs/core.cljs"}, :name cljs.core/pop!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 3247, :end-line 3247, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :test true}, chunk-append {:protocol-inline nil, :meta {:arglists (quote ([b x])), :end-column 19, :end-line 3018, :column 7, :line 3018, :file "cljs/core.cljs"}, :name cljs.core/chunk-append, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 3018, :end-line 3018, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x])), :test true}, prn-str {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :end-column 14, :end-line 8592, :column 7, :line 8592, :file "cljs/core.cljs"}, :name cljs.core/prn-str, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic true, :max-fixed-arity 0}), :line 8592, :end-line 8592, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :test true}, IReversible {:meta {:protocol-info {:methods {-rseq [[coll]]}}, :protocol-symbol true, :doc "Protocol for reversing a seq.", :end-column 25, :end-line 496, :column 14, :line 496, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column 1, :line 496, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 496, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for reversing a seq.", :test true}, reversible? {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible.", :tag boolean, :end-column 27, :end-line 2655, :column 16, :line 2655, :file "cljs/core.cljs"}, :name cljs.core/reversible?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2655, :ret-tag boolean, :end-line 2655, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible.", :test true}, -realized? {:protocol-inline nil, :meta {:arglists (quote ([d])), :doc "Returns true if a value for d has been produced, false otherwise.", :protocol cljs.core/IPending, :tag boolean, :end-column 23, :end-line 536, :column 13, :line 536, :file "cljs/core.cljs"}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 533, :ret-tag boolean, :end-line 536, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value for d has been produced, false otherwise.", :test true}, -add-watch {:protocol-inline nil, :meta {:arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :protocol cljs.core/IWatchable, :end-column 14, :end-line 543, :column 4, :line 543, :file "cljs/core.cljs"}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 539, :end-line 543, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :test true}, -deref-with-timeout {:protocol-inline nil, :meta {:arglists (quote ([o msec timeout-val])), :doc nil, :protocol cljs.core/IDerefWithTimeout, :end-column 23, :end-line 445, :column 4, :line 445, :file "cljs/core.cljs"}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 444, :end-line 445, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil, :test true}, conj {:protocol-inline nil, :meta {:arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :end-column 11, :end-line 1422, :column 7, :line 1422, :file "cljs/core.cljs"}, :name cljs.core/conj, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([] [coll] [coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 1422, :end-line 1422, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :test true}, -sorted-seq {:protocol-inline nil, :meta {:arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.", :protocol cljs.core/ISorted, :tag clj, :end-column 20, :end-line 504, :column 9, :line 504, :file "cljs/core.cljs"}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 501, :ret-tag clj, :end-line 504, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.", :test true}, flatten1 {:protocol-inline nil, :meta {:arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :private true, :end-column 16, :end-line 4221, :column 8, :line 4221, :file "cljs/core.cljs"}, :private true, :name cljs.core/flatten1, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 4221, :end-line 4221, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :test true}, transduce {:protocol-inline nil, :meta {:arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :end-column 16, :end-line 2082, :column 7, :line 2082, :file "cljs/core.cljs"}, :name cljs.core/transduce, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4}), :line 2082, :end-line 2082, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :test true}, fixture1 {:meta {:end-column 14, :end-line 8834, :column 6, :line 8834, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 8834, :column 1, :end-line 8834, :end-column 14, :test true, :name cljs.core/fixture1}, -swap! {:protocol-inline nil, :meta {:arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :protocol cljs.core/ISwap, :end-column 10, :end-line 624, :column 4, :line 624, :file "cljs/core.cljs"}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5}), :line 622, :end-line 624, :max-fixed-arity 5, :fn-var true, :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :test true}, *print-length* {:meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :dynamic true, :end-column 17, :end-line 85, :column 3, :line 85, :file "cljs/core.cljs"}, :name cljs.core/*print-length*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 79, :end-line 85, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :test true}, js-delete {:protocol-inline nil, :meta {:arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object.", :end-column 16, :end-line 1807, :column 7, :line 1807, :file "cljs/core.cljs"}, :name cljs.core/js-delete, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 1807, :end-line 1807, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object.", :test true}, truth_ {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Internal - do not use!", :end-column 13, :end-line 134, :column 7, :line 134, :file "cljs/core.cljs"}, :name cljs.core/truth_, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 134, :end-line 134, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!", :test true}, ->MultiFn {:protocol-inline nil, :meta {:arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :factory :positional, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :end-column 17, :end-line 9250, :column 10, :line 9250, :file "cljs/core.cljs"}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiFn, :variadic false, :max-fixed-arity 8}), :line 9250, :end-line 9250, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :test true}, key->js {:protocol-inline nil, :meta {:arglists (quote ([k])), :end-column 14, :end-line 8948, :column 7, :line 8948, :file "cljs/core.cljs"}, :name cljs.core/key->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic false, :max-fixed-arity 1}), :line 8948, :end-line 8948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ->MultiStepper {:protocol-inline nil, :meta {:arglists (quote ([xform iters nexts])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 22, :end-line 3444, :column 10, :line 3444, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiStepper, :variadic false, :max-fixed-arity 3}), :line 3444, :end-line 3444, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil, :test true}, IEncodeJS {:meta {:protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :protocol-symbol true, :doc nil, :end-column 23, :end-line 8941, :column 14, :line 8941, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column 1, :line 8941, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 8941, :impls #{}, :doc nil, :test true}, new-path {:protocol-inline nil, :meta {:arglists (quote ([edit level node])), :private true, :end-column 16, :end-line 4461, :column 8, :line 4461, :file "cljs/core.cljs"}, :private true, :name cljs.core/new-path, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4461, :end-line 4461, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node])), :test true}, compare-and-set! {:protocol-inline nil, :meta {:arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :end-column 23, :end-line 3860, :column 7, :line 3860, :file "cljs/core.cljs"}, :name cljs.core/compare-and-set!, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 3}), :line 3860, :end-line 3860, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :test true}, array-seq {:protocol-inline nil, :meta {:arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :end-column 16, :end-line 1321, :column 7, :line 1321, :file "cljs/core.cljs"}, :name cljs.core/array-seq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1321, :end-line 1321, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :test true}, array-copy-downward {:protocol-inline nil, :meta {:arglists (quote ([from i to j len])), :private true, :end-column 27, :end-line 1820, :column 8, :line 1820, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1820, :end-line 1820, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, pack-array-node {:protocol-inline nil, :meta {:arglists (quote ([array-node edit idx])), :private true, :end-column 23, :end-line 6152, :column 8, :line 6152, :file "cljs/core.cljs"}, :private true, :name cljs.core/pack-array-node, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 6152, :end-line 6152, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx])), :test true}, interleave {:protocol-inline nil, :meta {:arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :end-column 17, :end-line 4186, :column 7, :line 4186, :file "cljs/core.cljs"}, :name cljs.core/interleave, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([c1 c2] [c1 c2 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 4186, :end-line 4186, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :test true}, print-map {:protocol-inline nil, :meta {:arglists (quote ([m print-one writer opts])), :end-column 16, :end-line 8636, :column 7, :line 8636, :file "cljs/core.cljs"}, :name cljs.core/print-map, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 8636, :end-line 8636, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts])), :test true}, map? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x satisfies IMap", :tag boolean, :end-column 20, :end-line 1774, :column 16, :line 1774, :file "cljs/core.cljs"}, :name cljs.core/map?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1774, :ret-tag boolean, :end-line 1774, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap", :test true}, m3-C1 {:meta {:end-column 11, :end-line 679, :column 6, :line 679, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 679, :column 1, :end-line 679, :end-column 11, :test true, :name cljs.core/m3-C1}, get {:protocol-inline nil, :meta {:arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :end-column 10, :end-line 1562, :column 7, :line 1562, :file "cljs/core.cljs"}, :name cljs.core/get, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1562, :end-line 1562, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :test true}, identity {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns its argument.", :end-column 15, :end-line 2067, :column 7, :line 2067, :file "cljs/core.cljs"}, :name cljs.core/identity, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2067, :end-line 2067, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument.", :test true}, into {:protocol-inline nil, :meta {:arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :end-column 11, :end-line 4305, :column 7, :line 4305, :file "cljs/core.cljs"}, :name cljs.core/into, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4305, :end-line 4305, :max-fixed-arity 3, :fn-var true, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :test true}, long {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-column 11, :end-line 2308, :column 7, :line 2308, :file "cljs/core.cljs"}, :name cljs.core/long, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2308, :end-line 2308, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, double {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 21, :end-line 2209, :column 15, :line 2209, :file "cljs/core.cljs"}, :name cljs.core/double, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2209, :ret-tag number, :end-line 2209, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, volatile? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is a volatile.", :end-column 16, :end-line 3897, :column 7, :line 3897, :file "cljs/core.cljs"}, :name cljs.core/volatile?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3897, :end-line 3897, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile.", :test true}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2900, :record false, :end-line 2900, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the key of the map entry.", :protocol cljs.core/IMapEntry, :end-column 8, :end-line 414, :column 4, :line 414, :file "cljs/core.cljs"}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 412, :end-line 414, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry.", :test true}, nfirst {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Same as (next (first x))", :end-column 13, :end-line 1395, :column 7, :line 1395, :file "cljs/core.cljs"}, :name cljs.core/nfirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1395, :end-line 1395, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))", :test true}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 640, :record false, :end-line 640, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata.", :end-column 11, :end-line 1702, :column 7, :line 1702, :file "cljs/core.cljs"}, :name cljs.core/meta, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1702, :end-line 1702, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata.", :test true}, tv-editable-tail {:protocol-inline nil, :meta {:arglists (quote ([tl])), :private true, :end-column 24, :end-line 5002, :column 8, :line 5002, :file "cljs/core.cljs"}, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 5002, :end-line 5002, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl])), :test true}, -kv-reduce {:protocol-inline nil, :meta {:arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :protocol cljs.core/IKVReduce, :end-column 14, :end-line 468, :column 4, :line 468, :file "cljs/core.cljs"}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 465, :end-line 468, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :test true}, IHash {:meta {:protocol-info {:methods {-hash [[o]]}}, :protocol-symbol true, :doc "Protocol for adding hashing functionality to a type.", :end-column 19, :end-line 477, :column 14, :line 477, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column 1, :line 477, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 477, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type.", :test true}, bit-and-not {:protocol-inline nil, :meta {:arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :end-column 18, :end-line 2367, :column 7, :line 2367, :file "cljs/core.cljs"}, :name cljs.core/bit-and-not, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2367, :end-line 2367, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :test true}, -comparator {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the comparator for coll.", :protocol cljs.core/ISorted, :end-column 15, :end-line 515, :column 4, :line 515, :file "cljs/core.cljs"}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 501, :end-line 515, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll.", :test true}, unchecked-add-int {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :tag number, :end-column 32, :end-line 2224, :column 15, :line 2224, :file "cljs/core.cljs"}, :name cljs.core/unchecked-add-int, :variadic true, :file "cljs/core.cljs", :end-column 32, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2224, :ret-tag number, :end-line 2224, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, t7427 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7427, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, hash-ordered-coll {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :tag number, :end-column 32, :end-line 1053, :column 15, :line 1053, :file "cljs/core.cljs"}, :name cljs.core/hash-ordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1053, :ret-tag number, :end-line 1053, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, extend-object! {:protocol-inline nil, :meta {:arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :private true, :end-column 22, :end-line 2526, :column 8, :line 2526, :file "cljs/core.cljs"}, :private true, :name cljs.core/extend-object!, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 2526, :end-line 2526, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :test true}, do-assoc {:protocol-inline nil, :meta {:arglists (quote ([pv level node i val])), :private true, :end-column 16, :end-line 4514, :column 8, :line 4514, :file "cljs/core.cljs"}, :private true, :name cljs.core/do-assoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 5}), :line 4514, :end-line 4514, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val])), :test true}, reset-meta! {:protocol-inline nil, :meta {:arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom", :end-column 18, :end-line 8780, :column 7, :line 8780, :file "cljs/core.cljs"}, :name cljs.core/reset-meta!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8780, :end-line 8780, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom", :test true}, ->KeySeq {:protocol-inline nil, :meta {:arglists (quote ([mseq _meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 16, :end-line 7476, :column 10, :line 7476, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/KeySeq, :variadic false, :max-fixed-arity 2}), :line 7476, :end-line 7476, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, IEquiv {:meta {:protocol-info {:methods {-equiv [[o other]]}}, :protocol-symbol true, :doc "Protocol for adding value comparison functionality to a type.", :end-column 20, :end-line 472, :column 14, :line 472, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column 1, :line 472, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 472, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type.", :test true}, tree-map-kv-reduce {:protocol-inline nil, :meta {:arglists (quote ([node f init])), :private true, :end-column 26, :end-line 6909, :column 8, :line 6909, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 6909, :end-line 6909, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init])), :test true}, cycle {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :end-column 12, :end-line 4154, :column 7, :line 4154, :file "cljs/core.cljs"}, :name cljs.core/cycle, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 4154, :end-line 4154, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :test true}, -deref {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns the value of the reference o.", :protocol cljs.core/IDeref, :end-column 10, :end-line 441, :column 4, :line 441, :file "cljs/core.cljs"}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 439, :end-line 441, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o.", :test true}, pr-writer-ex-info {:protocol-inline nil, :meta {:arglists (quote ([obj writer opts])), :private true, :end-column 25, :end-line 9490, :column 8, :line 9490, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9490, :end-line 9490, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :test true}, empty? {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :tag boolean, :end-column 22, :end-line 1738, :column 16, :line 1738, :file "cljs/core.cljs"}, :name cljs.core/empty?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1738, :ret-tag boolean, :end-line 1738, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :test true}, short {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 20, :end-line 2207, :column 15, :line 2207, :file "cljs/core.cljs"}, :name cljs.core/short, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2207, :ret-tag number, :end-line 2207, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, -clj->js {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript", :protocol cljs.core/IEncodeJS, :end-column 12, :end-line 8942, :column 4, :line 8942, :file "cljs/core.cljs"}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8941, :end-line 8942, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript", :test true}, t20896 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t20896, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, -chunked-first {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the first chunk in coll.", :protocol cljs.core/IChunkedSeq, :end-column 18, :end-line 597, :column 4, :line 597, :file "cljs/core.cljs"}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 595, :end-line 597, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll.", :test true}, filterv {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :end-column 14, :end-line 4335, :column 7, :line 4335, :file "cljs/core.cljs"}, :name cljs.core/filterv, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 4335, :end-line 4335, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :test true}, tv-editable-root {:protocol-inline nil, :meta {:arglists (quote ([node])), :private true, :end-column 24, :end-line 4999, :column 8, :line 4999, :file "cljs/core.cljs"}, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4999, :end-line 4999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, hash {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :end-column 11, :end-line 753, :column 7, :line 753, :file "cljs/core.cljs"}, :name cljs.core/hash, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 753, :end-line 753, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :test true}, quot {:protocol-inline nil, :meta {:arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator.", :end-column 11, :end-line 2337, :column 7, :line 2337, :file "cljs/core.cljs"}, :name cljs.core/quot, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2337, :end-line 2337, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator.", :test true}, unchecked-double {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 31, :end-line 2215, :column 15, :line 2215, :file "cljs/core.cljs"}, :name cljs.core/unchecked-double, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2215, :ret-tag number, :end-line 2215, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, *target* {:meta {:jsdoc ["@define {string}"], :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :dynamic true, :end-column 11, :end-line 27, :column 3, :line 27, :file "cljs/core.cljs"}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 20, :end-line 27, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :jsdoc ["@define {string}"], :test true}, ->ChunkedCons {:protocol-inline nil, :meta {:arglists (quote ([chunk more meta __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :end-column 21, :end-line 2949, :column 10, :line 2949, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedCons, :variadic false, :max-fixed-arity 4}), :line 2949, :end-line 2949, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, ranged-iterator {:protocol-inline nil, :meta {:arglists (quote ([v start end])), :end-column 22, :end-line 4550, :column 7, :line 4550, :file "cljs/core.cljs"}, :name cljs.core/ranged-iterator, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 3}), :line 4550, :end-line 4550, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end])), :test true}, ITransientVector {:meta {:protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :protocol-symbol true, :doc "Protocol for adding vector functionality to transient collections.", :end-column 30, :end-line 572, :column 14, :line 572, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column 1, :line 572, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 572, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections.", :test true}, key {:protocol-inline nil, :meta {:arglists (quote ([map-entry])), :doc "Returns the key of the map entry.", :end-column 10, :end-line 7539, :column 7, :line 7539, :file "cljs/core.cljs"}, :name cljs.core/key, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7539, :end-line 7539, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry.", :test true}, longs {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 12, :end-line 2325, :column 7, :line 2325, :file "cljs/core.cljs"}, :name cljs.core/longs, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2325, :end-line 2325, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, not= {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :tag boolean, :end-column 20, :end-line 3335, :column 16, :line 3335, :file "cljs/core.cljs"}, :name cljs.core/not=, :variadic true, :file "cljs/core.cljs", :end-column 20, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 3335, :ret-tag boolean, :end-line 3335, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :test true}, string? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is a JavaScript string.", :tag boolean, :end-column 23, :end-line 180, :column 16, :line 180, :file "cljs/core.cljs"}, :name cljs.core/string?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 180, :ret-tag boolean, :end-line 180, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string.", :test true}, es6-iterator {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :end-column 19, :end-line 1014, :column 7, :line 1014, :file "cljs/core.cljs"}, :name cljs.core/es6-iterator, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 1014, :end-line 1014, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :test true}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8839, :record false, :end-line 8839, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, pr-str-with-opts {:protocol-inline nil, :meta {:arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :end-column 23, :end-line 8559, :column 7, :line 8559, :file "cljs/core.cljs"}, :name cljs.core/pr-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic false, :max-fixed-arity 2}), :line 8559, :end-line 8559, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :test true}, m3-C2 {:meta {:end-column 11, :end-line 680, :column 6, :line 680, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 680, :column 1, :end-line 680, :end-column 11, :test true, :name cljs.core/m3-C2}, ->Symbol {:protocol-inline nil, :meta {:arglists (quote ([ns name str _hash _meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :end-column 16, :end-line 814, :column 10, :line 814, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 5}), :line 814, :end-line 814, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, *print-newline* {:meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :dynamic true, :end-column 18, :end-line 53, :column 3, :line 53, :file "cljs/core.cljs"}, :name cljs.core/*print-newline*, :file "cljs/core.cljs", :end-column 18, :column 1, :dynamic true, :line 48, :end-line 53, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :test true}, unchecked-multiply-int {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :tag number, :end-column 37, :end-line 2261, :column 15, :line 2261, :file "cljs/core.cljs"}, :name cljs.core/unchecked-multiply-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2261, :ret-tag number, :end-line 2261, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, chunk-rest {:protocol-inline nil, :meta {:arglists (quote ([s])), :end-column 17, :end-line 3027, :column 7, :line 3027, :file "cljs/core.cljs"}, :name cljs.core/chunk-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3027, :end-line 3027, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, remove-all-methods {:protocol-inline nil, :meta {:arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod.", :end-column 25, :end-line 9435, :column 7, :line 9435, :file "cljs/core.cljs"}, :name cljs.core/remove-all-methods, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9435, :end-line 9435, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod.", :test true}, trampoline {:protocol-inline nil, :meta {:arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :end-column 17, :end-line 9027, :column 7, :line 9027, :file "cljs/core.cljs"}, :name cljs.core/trampoline, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([f] [f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 9027, :end-line 9027, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :test true}, pr-opts {:protocol-inline nil, :meta {:arglists (quote ([])), :private true, :end-column 15, :end-line 101, :column 8, :line 101, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-opts, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 101, :end-line 101, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, *1 {:meta {:doc "bound in a repl thread to the most recent value printed", :end-column 5, :end-line 120, :column 3, :line 120, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 118, :column 1, :end-line 120, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :test true, :name cljs.core/*1}, vec {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :end-column 10, :end-line 4762, :column 7, :line 4762, :file "cljs/core.cljs"}, :name cljs.core/vec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any}, :variadic false, :max-fixed-arity 1}), :line 4762, :end-line 4762, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :test true}, *print-meta* {:meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :dynamic true, :end-column 15, :end-line 69, :column 3, :line 69, :file "cljs/core.cljs"}, :name cljs.core/*print-meta*, :file "cljs/core.cljs", :end-column 15, :column 1, :dynamic true, :line 63, :end-line 69, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :test true}, -notify-watches {:protocol-inline nil, :meta {:arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval.", :protocol cljs.core/IWatchable, :end-column 19, :end-line 541, :column 4, :line 541, :file "cljs/core.cljs"}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 539, :end-line 541, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval.", :test true}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 9250, :record false, :end-line 9250, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :end-column 10, :end-line 2298, :column 7, :line 2298, :file "cljs/core.cljs"}, :name cljs.core/int, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2298, :end-line 2298, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, ->ValSeq {:protocol-inline nil, :meta {:arglists (quote ([mseq _meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 16, :end-line 7544, :column 10, :line 7544, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ValSeq, :variadic false, :max-fixed-arity 2}), :line 7544, :end-line 7544, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, rand {:protocol-inline nil, :meta {:arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :end-column 11, :end-line 9043, :column 7, :line 9043, :file "cljs/core.cljs"}, :name cljs.core/rand, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:tag number, :variadic false, :max-fixed-arity 1}), :line 9043, :end-line 9043, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :test true}, second {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Same as (first (next x))", :end-column 13, :end-line 1385, :column 7, :line 1385, :file "cljs/core.cljs"}, :name cljs.core/second, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1385, :end-line 1385, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IEditableCollection {:meta {:protocol-info {:methods {-as-transient [[coll]]}}, :protocol-symbol true, :doc "Protocol for collections which can transformed to transients.", :end-column 33, :end-line 549, :column 14, :line 549, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column 1, :line 549, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 549, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients.", :test true}, hash-combine {:protocol-inline nil, :meta {:arglists (quote ([seed hash])), :end-column 19, :end-line 779, :column 7, :line 779, :file "cljs/core.cljs"}, :name cljs.core/hash-combine, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 779, :end-line 779, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash])), :test true}, > {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :tag boolean, :end-column 17, :end-line 2155, :column 16, :line 2155, :file "cljs/core.cljs"}, :name cljs.core/>, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2155, :ret-tag boolean, :end-line 2155, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :test true}, -name {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns the name String of x.", :protocol cljs.core/INamed, :tag string, :end-column 17, :end-line 609, :column 12, :line 609, :file "cljs/core.cljs"}, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 607, :ret-tag string, :end-line 609, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x.", :test true}, replace {:protocol-inline nil, :meta {:arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :end-column 14, :end-line 7920, :column 7, :line 7920, :file "cljs/core.cljs"}, :name cljs.core/replace, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag #{nil any cljs.core/LazySeq}, :variadic false, :max-fixed-arity 2}), :line 7920, :end-line 7920, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :test true}, ->Subvec {:protocol-inline nil, :meta {:arglists (quote ([meta v start end __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :end-column 16, :end-line 4866, :column 10, :line 4866, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4866, :end-line 4866, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, associative? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll implements Associative", :tag boolean, :end-column 28, :end-line 1758, :column 16, :line 1758, :file "cljs/core.cljs"}, :name cljs.core/associative?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1758, :ret-tag boolean, :end-line 1758, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative", :test true}, unchecked-int {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :end-column 20, :end-line 2303, :column 7, :line 2303, :file "cljs/core.cljs"}, :name cljs.core/unchecked-int, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2303, :end-line 2303, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, js-keys {:protocol-inline nil, :meta {:arglists (quote ([obj])), :doc "Return the JavaScript keys for an object.", :end-column 14, :end-line 1800, :column 7, :line 1800, :file "cljs/core.cljs"}, :name cljs.core/js-keys, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 1800, :end-line 1800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object.", :test true}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5460, :record false, :end-line 5460, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x is a Keyword", :tag boolean, :end-column 24, :end-line 2795, :column 16, :line 2795, :file "cljs/core.cljs"}, :name cljs.core/keyword?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2795, :ret-tag boolean, :end-line 2795, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword", :test true}, array-iter {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 17, :end-line 3374, :column 7, :line 3374, :file "cljs/core.cljs"}, :name cljs.core/array-iter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 1}), :line 3374, :end-line 3374, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, force {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :end-column 12, :end-line 8855, :column 7, :line 8855, :file "cljs/core.cljs"}, :name cljs.core/force, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8855, :end-line 8855, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :test true}, group-by {:protocol-inline nil, :meta {:arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :end-column 15, :end-line 9060, :column 7, :line 9060, :file "cljs/core.cljs"}, :name cljs.core/group-by, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 9060, :end-line 9060, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :test true}, -rseq {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order.", :protocol cljs.core/IReversible, :tag clj, :end-column 14, :end-line 498, :column 9, :line 498, :file "cljs/core.cljs"}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 496, :ret-tag clj, :end-line 498, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order.", :test true}, prn {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :end-column 10, :end-line 8629, :column 7, :line 8629, :file "cljs/core.cljs"}, :name cljs.core/prn, :variadic true, :file "cljs/core.cljs", :end-column 10, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8629, :end-line 8629, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :test true}, tv-pop-tail {:protocol-inline nil, :meta {:arglists (quote ([tv level node])), :private true, :end-column 19, :end-line 5019, :column 8, :line 5019, :file "cljs/core.cljs"}, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5019, :end-line 5019, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node])), :test true}, ->Atom {:protocol-inline nil, :meta {:arglists (quote ([state meta validator watches])), :factory :positional, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :end-column 14, :end-line 3775, :column 10, :line 3775, :file "cljs/core.cljs"}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Atom, :variadic false, :max-fixed-arity 4}), :line 3775, :end-line 3775, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :test true}, PersistentHashMap {:meta {:declared true, :end-column 44, :end-line 5880, :column 27, :line 5880, :file "cljs/core.cljs"}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6505, :record false, :declared true, :end-line 6505, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, unchecked-multiply {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :tag number, :end-column 33, :end-line 2254, :column 15, :line 2254, :file "cljs/core.cljs"}, :name cljs.core/unchecked-multiply, :variadic true, :file "cljs/core.cljs", :end-column 33, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2254, :ret-tag number, :end-line 2254, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 6450, :record false, :end-line 6450, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer", :tag boolean, :end-column 21, :end-line 3607, :column 16, :line 3607, :file "cljs/core.cljs"}, :name cljs.core/even?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3607, :ret-tag boolean, :end-line 3607, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer", :test true}, es6-iterator-seq {:protocol-inline nil, :meta {:arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :end-column 23, :end-line 1031, :column 7, :line 1031, :file "cljs/core.cljs"}, :name cljs.core/es6-iterator-seq, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 1031, :end-line 1031, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :test true}, unchecked-dec {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns a number one less than x, an int.", :end-column 20, :end-line 2231, :column 7, :line 2231, :file "cljs/core.cljs"}, :name cljs.core/unchecked-dec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2231, :end-line 2231, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int.", :test true}, hash-collision-node-find-index {:protocol-inline nil, :meta {:arglists (quote ([arr cnt key])), :private true, :end-column 38, :end-line 6262, :column 8, :line 6262, :file "cljs/core.cljs"}, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 6262, :end-line 6262, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key])), :test true}, persistent-array-map-seq {:protocol-inline nil, :meta {:arglists (quote ([arr i _meta])), :end-column 31, :end-line 5617, :column 7, :line 5617, :file "cljs/core.cljs"}, :name cljs.core/persistent-array-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/PersistentArrayMapSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5617, :end-line 5617, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :test true}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 8102, :record false, :end-line 8102, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 3444, :record false, :end-line 3444, :skip-protocol-flag nil}, double-array {:protocol-inline nil, :meta {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :end-column 19, :end-line 3102, :column 7, :line 3102, :file "cljs/core.cljs"}, :name cljs.core/double-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 3102, :end-line 3102, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :test true}, ->EmptyList {:protocol-inline nil, :meta {:arglists (quote ([meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 19, :end-line 2599, :column 10, :line 2599, :file "cljs/core.cljs"}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/EmptyList, :variadic false, :max-fixed-arity 1}), :line 2599, :end-line 2599, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, seq-reduce {:protocol-inline nil, :meta {:arglists (quote ([f coll] [f val coll])), :private true, :end-column 18, :end-line 1989, :column 8, :line 1989, :file "cljs/core.cljs"}, :private true, :name cljs.core/seq-reduce, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1989, :end-line 1989, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :test true}, spread {:protocol-inline nil, :meta {:arglists (quote ([arglist])), :end-column 13, :end-line 3154, :column 7, :line 3154, :file "cljs/core.cljs"}, :name cljs.core/spread, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 3154, :end-line 3154, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist])), :test true}, balance-left {:protocol-inline nil, :meta {:arglists (quote ([key val ins right])), :private true, :end-column 20, :end-line 6824, :column 8, :line 6824, :file "cljs/core.cljs"}, :private true, :name cljs.core/balance-left, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6824, :end-line 6824, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right])), :test true}, rseq {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :tag seq, :end-column 16, :end-line 2660, :column 12, :line 2660, :file "cljs/core.cljs"}, :name cljs.core/rseq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2660, :ret-tag seq, :end-line 2660, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :test true}, ex-cause {:protocol-inline nil, :meta {:arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :end-column 15, :end-line 9554, :column 7, :line 9554, :file "cljs/core.cljs"}, :name cljs.core/ex-cause, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9554, :end-line 9554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :test true}, IReset {:meta {:protocol-info {:methods {-reset! [[o new-value]]}}, :protocol-symbol true, :doc "Protocol for adding resetting functionality.", :end-column 20, :end-line 617, :column 14, :line 617, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column 1, :line 617, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 617, :impls #{}, :doc "Protocol for adding resetting functionality.", :test true}, IEmptyableCollection {:meta {:protocol-info {:methods {-empty [[coll]]}}, :protocol-symbol true, :doc "Protocol for creating an empty collection.", :end-column 34, :end-line 347, :column 14, :line 347, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 347, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 347, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection.", :test true}, array-map-index-of {:protocol-inline nil, :meta {:arglists (quote ([m k])), :private true, :end-column 26, :end-line 5533, :column 8, :line 5533, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5533, :end-line 5533, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, ex-message {:protocol-inline nil, :meta {:arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :end-column 17, :end-line 9546, :column 7, :line 9546, :file "cljs/core.cljs"}, :name cljs.core/ex-message, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9546, :end-line 9546, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :test true}, string-print {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 19, :end-line 8443, :column 7, :line 8443, :file "cljs/core.cljs"}, :name cljs.core/string-print, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8443, :end-line 8443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, float {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 20, :end-line 2208, :column 15, :line 2208, :file "cljs/core.cljs"}, :name cljs.core/float, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2208, :ret-tag number, :end-line 2208, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, fixture2 {:meta {:end-column 14, :end-line 8835, :column 6, :line 8835, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 8835, :column 1, :end-line 8835, :end-column 14, :test true, :name cljs.core/fixture2}, IRecord {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker interface indicating a record object", :end-column 21, :end-line 493, :column 14, :line 493, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column 1, :line 493, :protocol-info {:methods {}}, :info nil, :end-line 493, :impls #{}, :doc "Marker interface indicating a record object", :test true}, pr-str {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :end-column 13, :end-line 8587, :column 7, :line 8587, :file "cljs/core.cljs"}, :name cljs.core/pr-str, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic true, :max-fixed-arity 0}), :line 8587, :end-line 8587, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :test true}, first-array-for-longvec {:protocol-inline nil, :meta {:arglists (quote ([pv])), :private true, :end-column 31, :end-line 4490, :column 8, :line 4490, :file "cljs/core.cljs"}, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 4490, :end-line 4490, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, es6-set-entries-iterator {:protocol-inline nil, :meta {:arglists (quote ([coll])), :end-column 31, :end-line 5482, :column 7, :line 5482, :file "cljs/core.cljs"}, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5482, :end-line 5482, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, concat {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :end-column 13, :end-line 3162, :column 7, :line 3162, :file "cljs/core.cljs"}, :name cljs.core/concat, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([] [x] [x y] [x y zs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 3162, :end-line 3162, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :test true}, -methods {:protocol-inline nil, :meta {:arglists (quote ([mf])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 12, :end-line 9244, :column 4, :line 9244, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9238, :end-line 9244, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil, :test true}, IDerefWithTimeout {:meta {:protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :protocol-symbol true, :doc nil, :end-column 31, :end-line 444, :column 14, :line 444, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column 1, :line 444, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 444, :impls #{}, :doc nil, :test true}, symbol {:protocol-inline nil, :meta {:arglists (quote ([name] [ns name])), :end-column 13, :end-line 848, :column 7, :line 848, :file "cljs/core.cljs"}, :name cljs.core/symbol, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 2}), :line 848, :end-line 848, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :test true}, to-array-2d {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :end-column 18, :end-line 3047, :column 7, :line 3047, :file "cljs/core.cljs"}, :name cljs.core/to-array-2d, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 3047, :end-line 3047, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :test true}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 4866, :record false, :end-line 4866, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:protocol-inline nil, :meta {:arglists (quote ([message data cause])), :jsdoc ["@constructor"], :end-column 16, :end-line 9502, :column 3, :line 9502, :file "cljs/core.cljs"}, :name cljs.core/ExceptionInfo, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9501, :end-line 9502, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"], :test true}, mod {:protocol-inline nil, :meta {:arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity.", :end-column 10, :end-line 2332, :column 7, :line 2332, :file "cljs/core.cljs"}, :name cljs.core/mod, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2332, :end-line 2332, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity.", :test true}, ISet {:meta {:protocol-info {:methods {-disjoin [[coll v]]}}, :protocol-symbol true, :doc "Protocol for adding set functionality to a collection.", :end-column 18, :end-line 419, :column 14, :line 419, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column 1, :line 419, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 419, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection.", :test true}, pop {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :end-column 10, :end-line 1716, :column 7, :line 1716, :file "cljs/core.cljs"}, :name cljs.core/pop, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1716, :end-line 1716, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :test true}, IPending {:meta {:protocol-info {:methods {-realized? [[d]]}}, :protocol-symbol true, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay.", :end-column 22, :end-line 533, :column 14, :line 533, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column 1, :line 533, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 533, :impls #{cljs.core/Delay}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay.", :test true}, -entry-key {:protocol-inline nil, :meta {:arglists (quote ([coll entry])), :doc "Returns the key for entry.", :protocol cljs.core/ISorted, :end-column 14, :end-line 513, :column 4, :line 513, :file "cljs/core.cljs"}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 501, :end-line 513, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry.", :test true}, pop-tail {:protocol-inline nil, :meta {:arglists (quote ([pv level node])), :private true, :end-column 16, :end-line 4524, :column 8, :line 4524, :file "cljs/core.cljs"}, :private true, :name cljs.core/pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4524, :end-line 4524, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node])), :test true}, dissoc! {:protocol-inline nil, :meta {:arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :end-column 14, :end-line 3237, :column 7, :line 3237, :file "cljs/core.cljs"}, :name cljs.core/dissoc!, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll key] [tcoll key ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 3237, :end-line 3237, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :test true}, reductions {:protocol-inline nil, :meta {:arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :end-column 17, :end-line 8286, :column 7, :line 8286, :file "cljs/core.cljs"}, :name cljs.core/reductions, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3}), :line 8286, :end-line 8286, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :test true}, indexed? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time", :tag boolean, :end-column 24, :end-line 1230, :column 16, :line 1230, :file "cljs/core.cljs"}, :name cljs.core/indexed?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1230, :ret-tag boolean, :end-line 1230, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time", :test true}, - {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :tag number, :end-column 16, :end-line 2108, :column 15, :line 2108, :file "cljs/core.cljs"}, :name cljs.core/-, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2108, :ret-tag number, :end-line 2108, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -equiv {:protocol-inline nil, :meta {:arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise.", :protocol cljs.core/IEquiv, :tag boolean, :end-column 19, :end-line 474, :column 13, :line 474, :file "cljs/core.cljs"}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 472, :ret-tag boolean, :end-line 474, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise.", :test true}, ->RangeIterator {:protocol-inline nil, :meta {:arglists (quote ([i end step])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 23, :end-line 8102, :column 10, :line 8102, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangeIterator, :variadic false, :max-fixed-arity 3}), :line 8102, :end-line 8102, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil, :test true}, ->ArrayNode {:protocol-inline nil, :meta {:arglists (quote ([edit cnt arr])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 19, :end-line 6165, :column 10, :line 6165, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNode, :variadic false, :max-fixed-arity 3}), :line 6165, :end-line 6165, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil, :test true}, assoc! {:protocol-inline nil, :meta {:arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :end-column 13, :end-line 3225, :column 7, :line 3225, :file "cljs/core.cljs"}, :name cljs.core/assoc!, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([tcoll key val] [tcoll key val kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 3225, :end-line 3225, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :test true}, hash-set {:protocol-inline nil, :meta {:arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-column 15, :end-line 7902, :column 7, :line 7902, :file "cljs/core.cljs"}, :name cljs.core/hash-set, :variadic true, :file "cljs/core.cljs", :end-column 15, :method-params ([] [keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ISet, :variadic false, :max-fixed-arity 0} {:tag clj, :variadic true, :max-fixed-arity 0}), :line 7902, :end-line 7902, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :test true}, reduce-kv {:protocol-inline nil, :meta {:arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :end-column 16, :end-line 2055, :column 7, :line 2055, :file "cljs/core.cljs"}, :name cljs.core/reduce-kv, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 2055, :end-line 2055, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :test true}, reset! {:meta {:declared true, :end-column 55, :end-line 5893, :column 49, :line 5893, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 5893, :column 1, :end-line 5893, :end-column 55, :declared true, :test true, :name cljs.core/reset!}, name {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword.", :end-column 11, :end-line 7970, :column 7, :line 7970, :file "cljs/core.cljs"}, :name cljs.core/name, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 1}), :line 7970, :end-line 7970, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword.", :test true}, ->RedNode {:protocol-inline nil, :meta {:arglists (quote ([key val left right __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :end-column 17, :end-line 7029, :column 10, :line 7029, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RedNode, :variadic false, :max-fixed-arity 5}), :line 7029, :end-line 7029, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, unchecked-array-for {:protocol-inline nil, :meta {:arglists (quote ([pv i])), :private true, :end-column 27, :end-line 4498, :column 8, :line 4498, :file "cljs/core.cljs"}, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4498, :end-line 4498, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, Fn {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker protocol", :end-column 16, :end-line 306, :column 14, :line 306, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column 1, :line 306, :protocol-info {:methods {}}, :info nil, :end-line 306, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol", :test true}, ffirst {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Same as (first (first x))", :end-column 13, :end-line 1390, :column 7, :line 1390, :file "cljs/core.cljs"}, :name cljs.core/ffirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1390, :end-line 1390, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))", :test true}, sorted-set {:protocol-inline nil, :meta {:arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :end-column 17, :end-line 7908, :column 7, :line 7908, :file "cljs/core.cljs"}, :name cljs.core/sorted-set, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 0}), :line 7908, :end-line 7908, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :test true}, pr-with-opts {:protocol-inline nil, :meta {:arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :private true, :end-column 20, :end-line 8576, :column 8, :line 8576, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8576, :end-line 8576, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :test true}, ->t4962 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta4963])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t4962, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta4963]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t4962, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta4963])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7279, :record false, :end-line 7279, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :meta {:arglists (quote ([comp tree cnt meta __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :end-column 27, :end-line 7279, :column 10, :line 7279, :file "cljs/core.cljs"}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMap, :variadic false, :max-fixed-arity 5}), :line 7279, :end-line 7279, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, array-reduce {:protocol-inline nil, :meta {:arglists (quote ([arr f] [arr f val] [arr f val idx])), :private true, :end-column 20, :end-line 1193, :column 8, :line 1193, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-reduce, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 1193, :end-line 1193, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :test true}, counted? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll implements count in constant time", :tag boolean, :end-column 24, :end-line 1226, :column 16, :line 1226, :file "cljs/core.cljs"}, :name cljs.core/counted?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1226, :ret-tag boolean, :end-line 1226, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time", :test true}, println {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :end-column 14, :end-line 8617, :column 7, :line 8617, :file "cljs/core.cljs"}, :name cljs.core/println, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8617, :end-line 8617, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :test true}, assoc-in {:protocol-inline nil, :meta {:arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :end-column 15, :end-line 4387, :column 7, :line 4387, :file "cljs/core.cljs"}, :name cljs.core/assoc-in, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__22452 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 4387, :end-line 4387, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :test true}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7654, :record false, :end-line 7654, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, t4965 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t4965, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3347, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, bit-test {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Test bit at index n", :tag boolean, :end-column 24, :end-line 2392, :column 16, :line 2392, :file "cljs/core.cljs"}, :name cljs.core/bit-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2392, :ret-tag boolean, :end-line 2392, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n", :test true}, TransientHashMap {:meta {:declared true, :end-column 26, :end-line 6503, :column 10, :line 6503, :file "cljs/core.cljs"}, :num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 6654, :record false, :declared true, :end-line 6654, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->PersistentHashMap {:protocol-inline nil, :meta {:arglists (quote ([meta cnt root has-nil? nil-val __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :end-column 27, :end-line 6505, :column 10, :line 6505, :file "cljs/core.cljs"}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashMap, :variadic false, :max-fixed-arity 6}), :line 6505, :end-line 6505, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, ISwap {:meta {:protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :protocol-symbol true, :doc "Protocol for adding swapping functionality.", :end-column 19, :end-line 622, :column 14, :line 622, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column 1, :line 622, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 622, :impls #{}, :doc "Protocol for adding swapping functionality.", :test true}, ChunkedCons {:meta {:declared true, :end-column 21, :end-line 1785, :column 10, :line 1785, :file "cljs/core.cljs"}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2949, :record false, :declared true, :end-line 2949, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, memoize {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :end-column 14, :end-line 9012, :column 7, :line 9012, :file "cljs/core.cljs"}, :name cljs.core/memoize, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 9012, :end-line 9012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :test true}, alter-meta! {:protocol-inline nil, :meta {:arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :end-column 18, :end-line 8771, :column 7, :line 8771, :file "cljs/core.cljs"}, :name cljs.core/alter-meta!, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([iref f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic true, :max-fixed-arity 2}), :line 8771, :end-line 8771, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :test true}, ->StringBufferWriter {:protocol-inline nil, :meta {:arglists (quote ([sb])), :factory :positional, :skip-protocol-flag #{cljs.core/IWriter}, :protocols #{cljs.core/IWriter}, :end-column 28, :end-line 640, :column 10, :line 640, :file "cljs/core.cljs"}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringBufferWriter, :variadic false, :max-fixed-arity 1}), :line 640, :end-line 640, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}, :test true}, zero? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if num is zero, else false", :tag boolean, :end-column 21, :end-line 2437, :column 16, :line 2437, :file "cljs/core.cljs"}, :name cljs.core/zero?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2437, :ret-tag boolean, :end-line 2437, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is zero, else false", :test true}, tv-ensure-editable {:protocol-inline nil, :meta {:arglists (quote ([edit node])), :private true, :end-column 26, :end-line 4994, :column 8, :line 4994, :file "cljs/core.cljs"}, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 2}), :line 4994, :end-line 4994, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node])), :test true}, *main-cli-fn* {:meta {:doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :end-column 16, :end-line 204, :column 3, :line 204, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 200, :column 1, :end-line 204, :end-column 16, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :test true, :name cljs.core/*main-cli-fn*}, -assoc-n {:protocol-inline nil, :meta {:arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n.", :protocol cljs.core/IVector, :tag clj, :end-column 17, :end-line 436, :column 9, :line 436, :file "cljs/core.cljs"}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 434, :ret-tag clj, :end-line 436, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n.", :test true}, unchecked-dec-int {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns a number one less than x, an int.", :end-column 24, :end-line 2236, :column 7, :line 2236, :file "cljs/core.cljs"}, :name cljs.core/unchecked-dec-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2236, :end-line 2236, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int.", :test true}, hash-imap {:protocol-inline nil, :meta {:arglists (quote ([m])), :private true, :end-column 17, :end-line 2505, :column 8, :line 2505, :file "cljs/core.cljs"}, :private true, :name cljs.core/hash-imap, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2505, :end-line 2505, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, dominates {:protocol-inline nil, :meta {:arglists (quote ([x y prefer-table])), :private true, :end-column 17, :end-line 9209, :column 8, :line 9209, :file "cljs/core.cljs"}, :private true, :name cljs.core/dominates, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 9209, :end-line 9209, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, persistent! {:protocol-inline nil, :meta {:arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :end-column 18, :end-line 3205, :column 7, :line 3205, :file "cljs/core.cljs"}, :name cljs.core/persistent!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 3205, :end-line 3205, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :test true}, set-print-fn! {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Set *print-fn* to f.", :end-column 20, :end-line 37, :column 7, :line 37, :file "cljs/core.cljs"}, :name cljs.core/set-print-fn!, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 37, :end-line 37, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f.", :test true}, nnext {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Same as (next (next x))", :end-column 12, :end-line 1405, :column 7, :line 1405, :file "cljs/core.cljs"}, :name cljs.core/nnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1405, :end-line 1405, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))", :test true}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 5891, :record false, :end-line 5891, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:arglists (quote ([key val left ins])), :private true, :end-column 21, :end-line 6849, :column 8, :line 6849, :file "cljs/core.cljs"}, :private true, :name cljs.core/balance-right, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6849, :end-line 6849, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins])), :test true}, throw-no-method-error {:protocol-inline nil, :meta {:arglists (quote ([name dispatch-val])), :private true, :end-column 29, :end-line 9247, :column 8, :line 9247, :file "cljs/core.cljs"}, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 9247, :end-line 9247, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val])), :test true}, add-watch {:protocol-inline nil, :meta {:arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :end-column 16, :end-line 8785, :column 7, :line 8785, :file "cljs/core.cljs"}, :name cljs.core/add-watch, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 8785, :end-line 8785, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :test true}, not-every? {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :tag boolean, :end-column 26, :end-line 3588, :column 16, :line 3588, :file "cljs/core.cljs"}, :name cljs.core/not-every?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3588, :ret-tag boolean, :end-line 3588, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :test true}, rem {:protocol-inline nil, :meta {:arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator.", :end-column 10, :end-line 2343, :column 7, :line 2343, :file "cljs/core.cljs"}, :name cljs.core/rem, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2343, :end-line 2343, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator.", :test true}, pr-sb-with-opts {:protocol-inline nil, :meta {:arglists (quote ([objs opts])), :private true, :end-column 23, :end-line 8552, :column 8, :line 8552, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag goog/string.StringBuffer, :variadic false, :max-fixed-arity 2}), :line 8552, :end-line 8552, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :test true}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 5954, :record false, :end-line 5954, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :meta {:arglists (quote ([meta nodes i s __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 17, :end-line 6387, :column 10, :line 6387, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NodeSeq, :variadic false, :max-fixed-arity 5}), :line 6387, :end-line 6387, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, some {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :end-column 11, :end-line 3593, :column 7, :line 3593, :file "cljs/core.cljs"}, :name cljs.core/some, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 3593, :end-line 3593, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :test true}, INamed {:meta {:protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :protocol-symbol true, :doc "Protocol for adding a name.", :end-column 20, :end-line 607, :column 14, :line 607, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column 1, :line 607, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 607, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name.", :test true}, ->Box {:protocol-inline nil, :meta {:arglists (quote ([val])), :factory :positional, :skip-protocol-flag nil, :protocols #{}, :end-column 13, :end-line 5891, :column 10, :line 5891, :file "cljs/core.cljs"}, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Box, :variadic false, :max-fixed-arity 1}), :line 5891, :end-line 5891, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil, :test true}, IReduce {:meta {:protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :protocol-symbol true, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :end-column 21, :end-line 457, :column 14, :line 457, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column 1, :line 457, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 457, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :test true}, drop {:protocol-inline nil, :meta {:arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :end-column 11, :end-line 4092, :column 7, :line 4092, :file "cljs/core.cljs"}, :name cljs.core/drop, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4092, :end-line 4092, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :test true}, js-obj {:protocol-inline nil, :meta {:arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :end-column 13, :end-line 1792, :column 7, :line 1792, :file "cljs/core.cljs"}, :name cljs.core/js-obj, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([] [keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 0} {:tag any, :variadic true, :max-fixed-arity 0}), :line 1792, :end-line 1792, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :test true}, ITransientCollection {:meta {:protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :protocol-symbol true, :doc "Protocol for adding basic functionality to transient collections.", :end-column 34, :end-line 554, :column 14, :line 554, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 554, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 554, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections.", :test true}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3775, :record false, :end-line 3775, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :end-column 10, :end-line 1490, :column 7, :line 1490, :file "cljs/core.cljs"}, :name cljs.core/nth, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1490, :end-line 1490, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :test true}, sorted? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted", :tag boolean, :end-column 23, :end-line 1766, :column 16, :line 1766, :file "cljs/core.cljs"}, :name cljs.core/sorted?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1766, :ret-tag boolean, :end-line 1766, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted", :test true}, nil? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise.", :tag boolean, :end-column 20, :end-line 148, :column 16, :line 148, :file "cljs/core.cljs"}, :name cljs.core/nil?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 148, :ret-tag boolean, :end-line 148, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise.", :test true}, split-at {:protocol-inline nil, :meta {:arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]", :end-column 15, :end-line 4160, :column 7, :line 4160, :file "cljs/core.cljs"}, :name cljs.core/split-at, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 4160, :end-line 4160, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]", :test true}, TransientHashSet {:meta {:declared true, :end-column 26, :end-line 7652, :column 10, :line 7652, :file "cljs/core.cljs"}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 7749, :record false, :declared true, :end-line 7749, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, *e {:meta {:doc "bound in a repl thread to the most recent exception caught by the repl", :end-column 5, :end-line 132, :column 3, :line 132, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 130, :column 1, :end-line 132, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :test true, :name cljs.core/*e}, array-map-extend-kv {:protocol-inline nil, :meta {:arglists (quote ([m k v])), :private true, :end-column 27, :end-line 5548, :column 8, :line 5548, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3}), :line 5548, :end-line 5548, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, prn-str-with-opts {:protocol-inline nil, :meta {:arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)", :end-column 24, :end-line 8567, :column 7, :line 8567, :file "cljs/core.cljs"}, :name cljs.core/prn-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic false, :max-fixed-arity 2}), :line 8567, :end-line 8567, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)", :test true}, not-native {:meta {:end-column 16, :end-line 139, :column 6, :line 139, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 139, :column 1, :end-line 139, :end-column 16, :test true, :name cljs.core/not-native}, ->t4965 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta4966])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t4965, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta4966]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t4965, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta4966])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, random-sample {:protocol-inline nil, :meta {:arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :end-column 20, :end-line 8905, :column 7, :line 8905, :file "cljs/core.cljs"}, :name cljs.core/random-sample, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8905, :end-line 8905, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :test true}, select-keys {:protocol-inline nil, :meta {:arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys", :end-column 18, :end-line 7636, :column 7, :line 7636, :file "cljs/core.cljs"}, :name cljs.core/select-keys, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7636, :end-line 7636, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys", :test true}, bit-and {:protocol-inline nil, :meta {:arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :end-column 14, :end-line 2355, :column 7, :line 2355, :file "cljs/core.cljs"}, :name cljs.core/bit-and, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2355, :end-line 2355, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :test true}, bounded-count {:protocol-inline nil, :meta {:arglists (quote ([s n])), :private true, :end-column 21, :end-line 3146, :column 8, :line 3146, :file "cljs/core.cljs"}, :private true, :name cljs.core/bounded-count, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 3146, :end-line 3146, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n])), :test true}, update {:protocol-inline nil, :meta {:arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :end-column 13, :end-line 4423, :column 7, :line 4423, :file "cljs/core.cljs"}, :name cljs.core/update, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4423, :end-line 4423, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :test true}, gensym_counter {:meta {:end-column 20, :end-line 8820, :column 6, :line 8820, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 8820, :column 1, :end-line 8820, :end-column 20, :test true, :name cljs.core/gensym_counter}, list* {:protocol-inline nil, :meta {:arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :end-column 12, :end-line 3187, :column 7, :line 3187, :file "cljs/core.cljs"}, :name cljs.core/list*, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([args] [a args] [a b args] [a b c args] [a b c d more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4} {:tag cljs.core/Cons, :variadic true, :max-fixed-arity 4}), :line 3187, :end-line 3187, :max-fixed-arity 4, :fn-var true, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :test true}, ->Keyword {:protocol-inline nil, :meta {:arglists (quote ([ns name fqn _hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :end-column 17, :end-line 2767, :column 10, :line 2767, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 4}), :line 2767, :end-line 2767, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, update-in {:protocol-inline nil, :meta {:arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :end-column 16, :end-line 4396, :column 7, :line 4396, :file "cljs/core.cljs"}, :name cljs.core/update-in, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([m p__22458 f] [m p__22459 f a] [m p__22460 f a b] [m p__22461 f a b c] [m p__22462 f a b c args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4396, :end-line 4396, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :test true}, prefer-method {:protocol-inline nil, :meta {:arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :end-column 20, :end-line 9445, :column 7, :line 9445, :file "cljs/core.cljs"}, :name cljs.core/prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9445, :end-line 9445, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :test true}, hash-symbol {:protocol-inline nil, :meta {:arglists (quote ([sym])), :private true, :end-column 19, :end-line 797, :column 8, :line 797, :file "cljs/core.cljs"}, :private true, :name cljs.core/hash-symbol, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 797, :end-line 797, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :test true}, ensure-reduced {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)", :end-column 21, :end-line 1140, :column 7, :line 1140, :file "cljs/core.cljs"}, :name cljs.core/ensure-reduced, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Reduced}, :variadic false, :max-fixed-arity 1}), :line 1140, :end-line 1140, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)", :test true}, edit-and-set {:protocol-inline nil, :meta {:arglists (quote ([inode edit i a] [inode edit i a j b])), :private true, :end-column 20, :end-line 5925, :column 8, :line 5925, :file "cljs/core.cljs"}, :private true, :name cljs.core/edit-and-set, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 6}), :line 5925, :end-line 5925, :max-fixed-arity 6, :fn-var true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :test true}, ->PersistentArrayMap {:protocol-inline nil, :meta {:arglists (quote ([meta cnt arr __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :end-column 28, :end-line 5632, :column 10, :line 5632, :file "cljs/core.cljs"}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMap, :variadic false, :max-fixed-arity 4}), :line 5632, :end-line 5632, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :test true}, instance? {:protocol-inline nil, :meta {:arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :tag boolean, :end-column 25, :end-line 786, :column 16, :line 786, :file "cljs/core.cljs"}, :name cljs.core/instance?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([t o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 786, :ret-tag boolean, :end-line 786, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :test true}, mix-collection-hash {:protocol-inline nil, :meta {:arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :tag number, :end-column 34, :end-line 1041, :column 15, :line 1041, :file "cljs/core.cljs"}, :name cljs.core/mix-collection-hash, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 1041, :ret-tag number, :end-line 1041, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, re-find {:protocol-inline nil, :meta {:arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :end-column 14, :end-line 8382, :column 7, :line 8382, :file "cljs/core.cljs"}, :name cljs.core/re-find, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8382, :end-line 8382, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :test true}, run! {:protocol-inline nil, :meta {:arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :end-column 11, :end-line 8935, :column 7, :line 8935, :file "cljs/core.cljs"}, :name cljs.core/run!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8935, :end-line 8935, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :test true}, char-escapes {:meta {:private true, :end-column 28, :end-line 8450, :column 16, :line 8450, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 8450, :column 1, :end-line 8450, :end-column 28, :private true, :test true, :name cljs.core/char-escapes}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1005, :record false, :end-line 1005, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:arglists (quote ([map-entry])), :doc "Returns the value in the map entry.", :end-column 10, :end-line 7607, :column 7, :line 7607, :file "cljs/core.cljs"}, :name cljs.core/val, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7607, :end-line 7607, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry.", :test true}, unchecked-add {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :tag number, :end-column 28, :end-line 2217, :column 15, :line 2217, :file "cljs/core.cljs"}, :name cljs.core/unchecked-add, :variadic true, :file "cljs/core.cljs", :end-column 28, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2217, :ret-tag number, :end-line 2217, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, not {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise.", :tag boolean, :end-column 19, :end-line 165, :column 16, :line 165, :file "cljs/core.cljs"}, :name cljs.core/not, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 165, :ret-tag boolean, :end-line 165, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise.", :test true}, -vreset! {:protocol-inline nil, :meta {:arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :protocol cljs.core/IVolatile, :end-column 12, :end-line 629, :column 4, :line 629, :file "cljs/core.cljs"}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 627, :end-line 629, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :test true}, fn->comparator {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :private true, :end-column 31, :end-line 1948, :column 17, :line 1948, :file "cljs/core.cljs"}, :private true, :name cljs.core/fn->comparator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number function}, :variadic false, :max-fixed-arity 1}), :line 1948, :end-line 1948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :test true}, with-meta {:protocol-inline nil, :meta {:arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :end-column 16, :end-line 1693, :column 7, :line 1693, :file "cljs/core.cljs"}, :name cljs.core/with-meta, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1693, :end-line 1693, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :test true}, unreduced {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x", :end-column 16, :end-line 1145, :column 7, :line 1145, :file "cljs/core.cljs"}, :name cljs.core/unreduced, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 1145, :end-line 1145, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x", :test true}, type {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return x's constructor.", :end-column 11, :end-line 206, :column 7, :line 206, :file "cljs/core.cljs"}, :name cljs.core/type, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 206, :end-line 206, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor.", :test true}, identical? {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object", :tag boolean, :end-column 26, :end-line 143, :column 16, :line 143, :file "cljs/core.cljs"}, :name cljs.core/identical?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 143, :ret-tag boolean, :end-line 143, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object", :test true}, -namespace {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns the namespace String of x.", :protocol cljs.core/INamed, :tag string, :end-column 22, :end-line 611, :column 12, :line 611, :file "cljs/core.cljs"}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 607, :ret-tag string, :end-line 611, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x.", :test true}, unchecked-divide-int {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :tag number, :end-column 35, :end-line 2241, :column 15, :line 2241, :file "cljs/core.cljs"}, :name cljs.core/unchecked-divide-int, :variadic true, :file "cljs/core.cljs", :end-column 35, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2241, :ret-tag number, :end-line 2241, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, swap-global-hierarchy! {:protocol-inline nil, :meta {:arglists (quote ([f & args])), :private true, :end-column 30, :end-line 9083, :column 8, :line 9083, :file "cljs/core.cljs"}, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "cljs/core.cljs", :end-column 30, :method-params ([f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 1}), :line 9083, :end-line 9083, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & args])), :test true}, max-key {:protocol-inline nil, :meta {:arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :end-column 14, :end-line 7991, :column 7, :line 7991, :file "cljs/core.cljs"}, :name cljs.core/max-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7991, :end-line 7991, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :test true}, ->PersistentTreeSet {:protocol-inline nil, :meta {:arglists (quote ([meta tree-map __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :end-column 27, :end-line 7786, :column 10, :line 7786, :file "cljs/core.cljs"}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeSet, :variadic false, :max-fixed-arity 3}), :line 7786, :end-line 7786, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, ->ChunkBuffer {:protocol-inline nil, :meta {:arglists (quote ([buf end])), :factory :positional, :skip-protocol-flag #{cljs.core/ICounted}, :protocols #{cljs.core/Object cljs.core/ICounted}, :end-column 21, :end-line 2900, :column 10, :line 2900, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 2}), :line 2900, :end-line 2900, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}, :test true}, hash-string {:protocol-inline nil, :meta {:arglists (quote ([k])), :end-column 18, :end-line 744, :column 7, :line 744, :file "cljs/core.cljs"}, :name cljs.core/hash-string, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 744, :end-line 744, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7544, :record false, :end-line 7544, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:arglists (quote ([mf])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 12, :end-line 9245, :column 4, :line 9245, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9238, :end-line 9245, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil, :test true}, set-validator! {:protocol-inline nil, :meta {:arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :end-column 21, :end-line 3869, :column 7, :line 3869, :file "cljs/core.cljs"}, :name cljs.core/set-validator!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3869, :end-line 3869, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :test true}, array-map-index-of-equiv? {:protocol-inline nil, :meta {:arglists (quote ([arr m k])), :private true, :end-column 33, :end-line 5525, :column 8, :line 5525, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of-equiv?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5525, :end-line 5525, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -meta {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns the metadata of object o.", :protocol cljs.core/IMeta, :tag clj-or-nil, :end-column 21, :end-line 449, :column 16, :line 449, :file "cljs/core.cljs"}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 447, :ret-tag clj-or-nil, :end-line 449, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o.", :test true}, RedNode {:meta {:declared true, :end-column 17, :end-line 6822, :column 10, :line 6822, :file "cljs/core.cljs"}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7029, :record false, :declared true, :end-line 7029, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:arglists (quote ([arr i])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 28, :end-line 1234, :column 10, :line 1234, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeqIterator, :variadic false, :max-fixed-arity 2}), :line 1234, :end-line 1234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, -add-method {:protocol-inline nil, :meta {:arglists (quote ([mf dispatch-val method])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 15, :end-line 9240, :column 4, :line 9240, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9238, :end-line 9240, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil, :test true}, balance-left-del {:protocol-inline nil, :meta {:arglists (quote ([key val del right])), :private true, :end-column 24, :end-line 6871, :column 8, :line 6871, :file "cljs/core.cljs"}, :private true, :name cljs.core/balance-left-del, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6871, :end-line 6871, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right])), :test true}, swap! {:protocol-inline nil, :meta {:arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :end-column 12, :end-line 3838, :column 7, :line 3838, :file "cljs/core.cljs"}, :name cljs.core/swap!, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([a f] [a f x] [a f x y] [a f x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic true, :max-fixed-arity 4}), :line 3838, :end-line 3838, :max-fixed-arity 4, :fn-var true, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :test true}, vals {:protocol-inline nil, :meta {:arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values.", :end-column 11, :end-line 7601, :column 7, :line 7601, :file "cljs/core.cljs"}, :name cljs.core/vals, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ValSeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7601, :end-line 7601, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values.", :test true}, -chunked-next {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk.", :protocol cljs.core/IChunkedNext, :end-column 17, :end-line 604, :column 4, :line 604, :file "cljs/core.cljs"}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 602, :end-line 604, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk.", :test true}, unchecked-subtract {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :tag number, :end-column 33, :end-line 2279, :column 15, :line 2279, :file "cljs/core.cljs"}, :name cljs.core/unchecked-subtract, :variadic true, :file "cljs/core.cljs", :end-column 33, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2279, :ret-tag number, :end-line 2279, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, remove-pair {:protocol-inline nil, :meta {:arglists (quote ([arr i])), :private true, :end-column 19, :end-line 5913, :column 8, :line 5913, :file "cljs/core.cljs"}, :private true, :name cljs.core/remove-pair, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 2}), :line 5913, :end-line 5913, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :test true}, IMap {:meta {:protocol-info {:methods {-dissoc [[coll k]]}}, :protocol-symbol true, :doc "Protocol for adding mapping functionality to collections.", :end-column 18, :end-line 406, :column 14, :line 406, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column 1, :line 406, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 406, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections.", :test true}, ->SeqIter {:protocol-inline nil, :meta {:arglists (quote ([_seq _next])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 17, :end-line 3380, :column 10, :line 3380, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 2}), :line 3380, :end-line 3380, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil, :test true}, sorted-set-by {:protocol-inline nil, :meta {:arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :end-column 20, :end-line 7913, :column 7, :line 7913, :file "cljs/core.cljs"}, :name cljs.core/sorted-set-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :method-params ([comparator keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 7913, :end-line 7913, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :test true}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4560, :record false, :end-line 4560, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol.", :end-column 17, :end-line 925, :column 7, :line 925, :file "cljs/core.cljs"}, :name cljs.core/cloneable?, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 925, :end-line 925, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol.", :test true}, hash-string* {:protocol-inline nil, :meta {:arglists (quote ([s])), :end-column 19, :end-line 727, :column 7, :line 727, :file "cljs/core.cljs"}, :name cljs.core/hash-string*, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 727, :end-line 727, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, key-test {:protocol-inline nil, :meta {:arglists (quote ([key other])), :tag boolean, :end-column 24, :end-line 5895, :column 16, :line 5895, :file "cljs/core.cljs"}, :name cljs.core/key-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 5895, :ret-tag boolean, :end-line 5895, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other])), :test true}, ->LazyTransformer {:protocol-inline nil, :meta {:arglists (quote ([stepper first rest meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :end-column 25, :end-line 3489, :column 10, :line 3489, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 4}), :line 3489, :end-line 3489, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, -reset {:protocol-inline nil, :meta {:arglists (quote ([mf])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 10, :end-line 9239, :column 4, :line 9239, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9238, :end-line 9239, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil, :test true}, true? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise.", :tag boolean, :end-column 21, :end-line 1836, :column 16, :line 1836, :file "cljs/core.cljs"}, :name cljs.core/true?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1836, :ret-tag boolean, :end-line 1836, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise.", :test true}, array {:protocol-inline nil, :meta {:arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args", :tag array, :end-column 19, :end-line 255, :column 14, :line 255, :file "cljs/core.cljs"}, :name cljs.core/array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 255, :ret-tag array, :end-line 255, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args", :test true}, print {:protocol-inline nil, :meta {:doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :end-column 8, :end-line 8608, :column 3, :line 8608, :file "cljs/core.cljs"}, :name cljs.core/print, :variadic true, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8605, :end-line 8608, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :test true}, -peek {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :protocol cljs.core/IStack, :end-column 9, :end-line 428, :column 4, :line 428, :file "cljs/core.cljs"}, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 424, :end-line 428, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :test true}, ISeq {:meta {:protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :protocol-symbol true, :doc "Protocol for collections to provide access to their items as sequences.", :end-column 18, :end-line 373, :column 14, :line 373, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 373, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 373, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences.", :test true}, ->t20893 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta20894])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t20893, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta20894]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t20893, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta20894])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, empty {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil", :end-column 12, :end-line 1437, :column 7, :line 1437, :file "cljs/core.cljs"}, :name cljs.core/empty, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1437, :end-line 1437, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil", :test true}, remove-method {:protocol-inline nil, :meta {:arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value.", :end-column 20, :end-line 9440, :column 7, :line 9440, :file "cljs/core.cljs"}, :name cljs.core/remove-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9440, :end-line 9440, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value.", :test true}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5182, :record false, :end-line 5182, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:arglists (quote ([key val left del])), :private true, :end-column 25, :end-line 6890, :column 8, :line 6890, :file "cljs/core.cljs"}, :private true, :name cljs.core/balance-right-del, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6890, :end-line 6890, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del])), :test true}, volatile! {:protocol-inline nil, :meta {:arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val.", :end-column 16, :end-line 3892, :column 7, :line 3892, :file "cljs/core.cljs"}, :name cljs.core/volatile!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3892, :end-line 3892, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val.", :test true}, / {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :tag number}, :name cljs.core//, :variadic true, :file "cljs/core.cljs", :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2124, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, bitpos {:protocol-inline nil, :meta {:arglists (quote ([hash shift])), :private true, :end-column 14, :end-line 5922, :column 8, :line 5922, :file "cljs/core.cljs"}, :private true, :name cljs.core/bitpos, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5922, :end-line 5922, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, bit-or {:protocol-inline nil, :meta {:arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :end-column 13, :end-line 2361, :column 7, :line 2361, :file "cljs/core.cljs"}, :name cljs.core/bit-or, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2361, :end-line 2361, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :test true}, m3-fmix {:protocol-inline nil, :meta {:arglists (quote ([h1 len])), :tag number, :end-column 22, :end-line 688, :column 15, :line 688, :file "cljs/core.cljs"}, :name cljs.core/m3-fmix, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 688, :ret-tag number, :end-line 688, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len])), :test true}, vector {:protocol-inline nil, :meta {:arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :end-column 13, :end-line 4773, :column 7, :line 4773, :file "cljs/core.cljs"}, :name cljs.core/vector, :variadic true, :file "cljs/core.cljs", :end-column 13, :method-params ([args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any}, :variadic true, :max-fixed-arity 0}), :line 4773, :end-line 4773, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :test true}, hash-coll {:protocol-inline nil, :meta {:arglists (quote ([coll])), :private true, :end-column 17, :end-line 2495, :column 8, :line 2495, :file "cljs/core.cljs"}, :private true, :name cljs.core/hash-coll, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 2495, :end-line 2495, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, clone-and-set {:protocol-inline nil, :meta {:arglists (quote ([arr i a] [arr i a j b])), :private true, :end-column 21, :end-line 5904, :column 8, :line 5904, :file "cljs/core.cljs"}, :private true, :name cljs.core/clone-and-set, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3} {:tag array, :variadic false, :max-fixed-arity 5}), :line 5904, :end-line 5904, :max-fixed-arity 5, :fn-var true, :arglists (quote ([arr i a] [arr i a j b])), :test true}, array->transient-hash-map {:protocol-inline nil, :meta {:arglists (quote ([len arr])), :private true, :end-column 33, :end-line 5882, :column 8, :line 5882, :file "cljs/core.cljs"}, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 5882, :end-line 5882, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr])), :test true}, >= {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :tag boolean, :end-column 18, :end-line 2167, :column 16, :line 2167, :file "cljs/core.cljs"}, :name cljs.core/>=, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2167, :ret-tag boolean, :end-line 2167, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :test true}, ->TransientHashSet {:protocol-inline nil, :meta {:arglists (quote ([transient-map])), :factory :positional, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :end-column 26, :end-line 7749, :column 10, :line 7749, :file "cljs/core.cljs"}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashSet, :variadic false, :max-fixed-arity 1}), :line 7749, :end-line 7749, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, drop-last {:protocol-inline nil, :meta {:arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :end-column 16, :end-line 4115, :column 7, :line 4115, :file "cljs/core.cljs"}, :name cljs.core/drop-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4115, :end-line 4115, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :test true}, ->ArrayIter {:protocol-inline nil, :meta {:arglists (quote ([arr i])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 19, :end-line 3365, :column 10, :line 3365, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 2}), :line 3365, :end-line 3365, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, object? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x's constructor is Object", :tag boolean, :end-column 23, :end-line 173, :column 16, :line 173, :file "cljs/core.cljs"}, :name cljs.core/object?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 173, :ret-tag boolean, :end-line 173, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object", :test true}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:arglists (quote ([meta nodes i s __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 22, :end-line 6450, :column 10, :line 6450, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNodeSeq, :variadic false, :max-fixed-arity 5}), :line 6450, :end-line 6450, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, tree-map-append {:protocol-inline nil, :meta {:arglists (quote ([left right])), :private true, :end-column 23, :end-line 7191, :column 8, :line 7191, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-append, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 2}), :line 7191, :end-line 7191, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right])), :test true}, not-empty {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll", :end-column 16, :end-line 3342, :column 7, :line 3342, :file "cljs/core.cljs"}, :name cljs.core/not-empty, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 3342, :end-line 3342, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll", :test true}, distinct {:protocol-inline nil, :meta {:arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :end-column 15, :end-line 7937, :column 7, :line 7937, :file "cljs/core.cljs"}, :name cljs.core/distinct, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 7937, :end-line 7937, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :test true}, partition {:protocol-inline nil, :meta {:arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :end-column 16, :end-line 4344, :column 7, :line 4344, :file "cljs/core.cljs"}, :name cljs.core/partition, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 4344, :end-line 4344, :max-fixed-arity 4, :fn-var true, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :test true}, IMultiFn {:meta {:protocol-info {:methods {-reset [[mf]], -add-method [[mf dispatch-val method]], -remove-method [[mf dispatch-val]], -prefer-method [[mf dispatch-val dispatch-val-y]], -get-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]]}}, :protocol-symbol true, :doc nil, :end-column 22, :end-line 9238, :column 14, :line 9238, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column 1, :line 9238, :protocol-info {:methods {-reset [[mf]], -add-method [[mf dispatch-val method]], -remove-method [[mf dispatch-val]], -prefer-method [[mf dispatch-val dispatch-val-y]], -get-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]]}}, :info nil, :end-line 9238, :impls #{cljs.core/MultiFn}, :doc nil, :test true}, fix {:protocol-inline nil, :meta {:arglists (quote ([q])), :private true, :tag number, :end-column 19, :end-line 2293, :column 16, :line 2293, :file "cljs/core.cljs"}, :private true, :name cljs.core/fix, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2293, :ret-tag number, :end-line 2293, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q])), :test true}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 2599, :record false, :end-line 2599, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:meta {:protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :protocol-symbol true, :doc "Protocol for adding associativity to collections.", :end-column 26, :end-line 397, :column 14, :line 397, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column 1, :line 397, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 397, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections.", :test true}, bit-flip {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Flip bit at index n", :end-column 15, :end-line 2378, :column 7, :line 2378, :file "cljs/core.cljs"}, :name cljs.core/bit-flip, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2378, :end-line 2378, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n", :test true}, long-array {:protocol-inline nil, :meta {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :end-column 17, :end-line 3080, :column 7, :line 3080, :file "cljs/core.cljs"}, :name cljs.core/long-array, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 3080, :end-line 3080, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :test true}, descendants {:protocol-inline nil, :meta {:arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :end-column 18, :end-line 9122, :column 7, :line 9122, :file "cljs/core.cljs"}, :name cljs.core/descendants, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 9122, :end-line 9122, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :test true}, imul {:protocol-inline nil, :meta {:arglists (quote ([a b])), :tag number, :end-column 21, :end-line 667, :column 17, :line 667, :file "cljs/core.cljs"}, :name cljs.core/imul, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 667, :ret-tag number, :end-line 667, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b])), :test true}, ->Delay {:protocol-inline nil, :meta {:arglists (quote ([f value])), :factory :positional, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :end-column 15, :end-line 8839, :column 10, :line 8839, :file "cljs/core.cljs"}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Delay, :variadic false, :max-fixed-arity 2}), :line 8839, :end-line 8839, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :test true}, array-for {:protocol-inline nil, :meta {:arglists (quote ([pv i])), :private true, :end-column 17, :end-line 4509, :column 8, :line 4509, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-for, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4509, :end-line 4509, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, merge {:protocol-inline nil, :meta {:arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :end-column 12, :end-line 7612, :column 7, :line 7612, :file "cljs/core.cljs"}, :name cljs.core/merge, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic true, :max-fixed-arity 0}), :line 7612, :end-line 7612, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :test true}, ISeqable {:meta {:protocol-info {:methods {-seq [[o]]}}, :protocol-symbol true, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :end-column 22, :end-line 482, :column 14, :line 482, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column 1, :line 482, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 482, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :test true}, js-mod {:protocol-inline nil, :meta {:arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :end-column 13, :end-line 2327, :column 7, :line 2327, :file "cljs/core.cljs"}, :name cljs.core/js-mod, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2327, :end-line 2327, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :test true}, ->t20896 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta20897])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t20896, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta20897]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t20896, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta20897])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, integer? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if n is an integer.", :tag boolean, :end-column 24, :end-line 1867, :column 16, :line 1867, :file "cljs/core.cljs"}, :name cljs.core/integer?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1867, :ret-tag boolean, :end-line 1867, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer.", :test true}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1640, :record false, :end-line 1640, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, mapv {:protocol-inline nil, :meta {:arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :end-column 11, :end-line 4319, :column 7, :line 4319, :file "cljs/core.cljs"}, :name cljs.core/mapv, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 4}), :line 4319, :end-line 4319, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :test true}, partition-all {:protocol-inline nil, :meta {:arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :end-column 20, :end-line 8016, :column 7, :line 8016, :file "cljs/core.cljs"}, :name cljs.core/partition-all, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 8016, :end-line 8016, :max-fixed-arity 3, :fn-var true, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :test true}, partition-by {:protocol-inline nil, :meta {:arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :end-column 19, :end-line 8236, :column 7, :line 8236, :file "cljs/core.cljs"}, :name cljs.core/partition-by, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8236, :end-line 8236, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :test true}, array-map-index-of-identical? {:protocol-inline nil, :meta {:arglists (quote ([arr m k])), :private true, :end-column 37, :end-line 5517, :column 8, :line 5517, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of-identical?, :variadic false, :file "cljs/core.cljs", :end-column 37, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5517, :end-line 5517, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ISequential {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker interface indicating a persistent collection of sequential items", :end-column 25, :end-line 487, :column 14, :line 487, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column 1, :line 487, :protocol-info {:methods {}}, :info nil, :end-line 487, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items", :test true}, ->LazySeq {:protocol-inline nil, :meta {:arglists (quote ([meta fn s __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 17, :end-line 2832, :column 10, :line 2832, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 2832, :end-line 2832, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, equiv-map {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false.", :private true, :end-column 17, :end-line 5289, :column 8, :line 5289, :file "cljs/core.cljs"}, :private true, :name cljs.core/equiv-map, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 5289, :end-line 5289, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false.", :test true}, ->t7427 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta7428])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7427, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta7428]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t7427, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7428])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, ->Volatile {:protocol-inline nil, :meta {:arglists (quote ([state])), :factory :positional, :skip-protocol-flag #{cljs.core/IDeref}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :end-column 18, :end-line 3884, :column 10, :line 3884, :file "cljs/core.cljs"}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3884, :end-line 3884, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, object-array {:protocol-inline nil, :meta {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :end-column 19, :end-line 3124, :column 7, :line 3124, :file "cljs/core.cljs"}, :name cljs.core/object-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 3124, :end-line 3124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :test true}, Keyword {:meta {:declared true, :end-column 27, :end-line 141, :column 20, :line 141, :file "cljs/core.cljs"}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2767, :record false, :declared true, :end-line 2767, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, derive {:protocol-inline nil, :meta {:arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-column 13, :end-line 9131, :column 7, :line 9131, :file "cljs/core.cljs"}, :name cljs.core/derive, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil cljs.core/IMap clj-nil}, :variadic false, :max-fixed-arity 3}), :line 9131, :end-line 9131, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, seq-iter {:protocol-inline nil, :meta {:arglists (quote ([coll])), :end-column 15, :end-line 3398, :column 7, :line 3398, :file "cljs/core.cljs"}, :name cljs.core/seq-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 1}), :line 3398, :end-line 3398, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IChunkedSeq {:meta {:protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :protocol-symbol true, :doc "Protocol for accessing a collection as sequential chunks.", :end-column 25, :end-line 595, :column 14, :line 595, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column 1, :line 595, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 595, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing a collection as sequential chunks.", :test true}, special-symbol? {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag boolean, :end-column 31, :end-line 9569, :column 16, :line 9569, :file "cljs/core.cljs"}, :name cljs.core/special-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 9569, :ret-tag boolean, :end-line 9569, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, compare-keywords {:protocol-inline nil, :meta {:arglists (quote ([a b])), :private true, :end-column 24, :end-line 2755, :column 8, :line 2755, :file "cljs/core.cljs"}, :private true, :name cljs.core/compare-keywords, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 2755, :end-line 2755, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, ancestors {:protocol-inline nil, :meta {:arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-column 16, :end-line 9114, :column 7, :line 9114, :file "cljs/core.cljs"}, :name cljs.core/ancestors, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 9114, :end-line 9114, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, subseq {:protocol-inline nil, :meta {:arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-column 13, :end-line 8072, :column 7, :line 8072, :file "cljs/core.cljs"}, :name cljs.core/subseq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 8072, :end-line 8072, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, LazyTransformer {:meta {:declared true, :end-column 25, :end-line 3410, :column 10, :line 3410, :file "cljs/core.cljs"}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 3489, :record false, :declared true, :end-line 3489, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, gensym {:protocol-inline nil, :meta {:arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :end-column 13, :end-line 8822, :column 7, :line 8822, :file "cljs/core.cljs"}, :name cljs.core/gensym, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 0} {:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1}), :line 8822, :end-line 8822, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :test true}, -next {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :protocol cljs.core/INext, :tag clj-or-nil, :end-column 21, :end-line 385, :column 16, :line 385, :file "cljs/core.cljs"}, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 383, :ret-tag clj-or-nil, :end-line 385, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :test true}, ->HashCollisionNode {:protocol-inline nil, :meta {:arglists (quote ([edit collision-hash cnt arr])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 27, :end-line 6271, :column 10, :line 6271, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/HashCollisionNode, :variadic false, :max-fixed-arity 4}), :line 6271, :end-line 6271, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil, :test true}, delay? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "returns true if x is a Delay created with delay", :tag boolean, :end-column 22, :end-line 8851, :column 16, :line 8851, :file "cljs/core.cljs"}, :name cljs.core/delay?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8851, :ret-tag boolean, :end-line 8851, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay", :test true}, create-inode-seq {:protocol-inline nil, :meta {:arglists (quote ([nodes] [nodes i s])), :private true, :end-column 24, :end-line 6433, :column 8, :line 6433, :file "cljs/core.cljs"}, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 6433, :end-line 6433, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nodes] [nodes i s])), :test true}, flatten {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :end-column 14, :end-line 4297, :column 7, :line 4297, :file "cljs/core.cljs"}, :name cljs.core/flatten, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 4297, :end-line 4297, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :test true}, -dissoc {:protocol-inline nil, :meta {:arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k.", :protocol cljs.core/IMap, :tag clj, :end-column 16, :end-line 409, :column 9, :line 409, :file "cljs/core.cljs"}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 406, :ret-tag clj, :end-line 409, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k.", :test true}, doubles {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 14, :end-line 2324, :column 7, :line 2324, :file "cljs/core.cljs"}, :name cljs.core/doubles, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2324, :end-line 2324, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -contains-key? {:protocol-inline nil, :meta {:arglists (quote ([coll k])), :doc "Returns true if k is a key in coll.", :protocol cljs.core/IAssociative, :tag boolean, :end-column 27, :end-line 399, :column 13, :line 399, :file "cljs/core.cljs"}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 397, :ret-tag boolean, :end-line 399, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll.", :test true}, remove-watch {:protocol-inline nil, :meta {:arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference", :end-column 19, :end-line 8810, :column 7, :line 8810, :file "cljs/core.cljs"}, :name cljs.core/remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8810, :end-line 8810, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference", :test true}, ex-info {:protocol-inline nil, :meta {:arglists (quote ([msg data] [msg data cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :end-column 14, :end-line 9530, :column 7, :line 9530, :file "cljs/core.cljs"}, :name cljs.core/ex-info, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9530, :end-line 9530, :max-fixed-arity 3, :fn-var true, :arglists (quote ([msg data] [msg data cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :test true}, ifn? {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn.", :tag boolean, :end-column 20, :end-line 1862, :column 16, :line 1862, :file "cljs/core.cljs"}, :name cljs.core/ifn?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1862, :ret-tag boolean, :end-line 1862, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn.", :test true}, IAtom {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker protocol indicating an atom.", :end-column 19, :end-line 614, :column 14, :line 614, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column 1, :line 614, :protocol-info {:methods {}}, :info nil, :end-line 614, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom.", :test true}, ->PersistentQueue {:protocol-inline nil, :meta {:arglists (quote ([meta count front rear __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :end-column 25, :end-line 5222, :column 10, :line 5222, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueue, :variadic false, :max-fixed-arity 5}), :line 5222, :end-line 5222, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :test true}, IWatchable {:meta {:protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :protocol-symbol true, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :end-column 24, :end-line 539, :column 14, :line 539, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 539, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 539, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :test true}, ->Stepper {:protocol-inline nil, :meta {:arglists (quote ([xform iter])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 17, :end-line 3415, :column 10, :line 3415, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Stepper, :variadic false, :max-fixed-arity 2}), :line 3415, :end-line 3415, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil, :test true}, pv-fresh-node {:protocol-inline nil, :meta {:arglists (quote ([edit])), :private true, :end-column 21, :end-line 4443, :column 8, :line 4443, :file "cljs/core.cljs"}, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4443, :end-line 4443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit])), :test true}, subvec {:protocol-inline nil, :meta {:arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :end-column 13, :end-line 4983, :column 7, :line 4983, :file "cljs/core.cljs"}, :name cljs.core/subvec, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 3}), :line 4983, :end-line 4983, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :test true}, -pop! {:protocol-inline nil, :meta {:arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it.", :protocol cljs.core/ITransientVector, :tag clj, :end-column 14, :end-line 576, :column 9, :line 576, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 572, :ret-tag clj, :end-line 576, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it.", :test true}, partial {:protocol-inline nil, :meta {:arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :end-column 14, :end-line 3660, :column 7, :line 3660, :file "cljs/core.cljs"}, :name cljs.core/partial, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4} {:tag function, :variadic true, :max-fixed-arity 4}), :line 3660, :end-line 3660, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :test true}, chunked-seq? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq.", :tag boolean, :end-column 28, :end-line 1787, :column 16, :line 1787, :file "cljs/core.cljs"}, :name cljs.core/chunked-seq?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1787, :ret-tag boolean, :end-line 1787, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq.", :test true}, replicate {:protocol-inline nil, :meta {:arglists (quote ([n x])), :doc "Returns a lazy seq of n xs.", :end-column 16, :end-line 4170, :column 7, :line 4170, :file "cljs/core.cljs"}, :name cljs.core/replicate, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4170, :end-line 4170, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs.", :test true}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5222, :record false, :end-line 5222, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :end-column 14, :end-line 7998, :column 7, :line 7998, :file "cljs/core.cljs"}, :name cljs.core/min-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7998, :end-line 7998, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :test true}, hash-iset {:protocol-inline nil, :meta {:arglists (quote ([s])), :private true, :end-column 17, :end-line 2515, :column 8, :line 2515, :file "cljs/core.cljs"}, :private true, :name cljs.core/hash-iset, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2515, :end-line 2515, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, reduced {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x", :end-column 14, :end-line 1130, :column 7, :line 1130, :file "cljs/core.cljs"}, :name cljs.core/reduced, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 1130, :end-line 1130, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x", :test true}, re-matches {:protocol-inline nil, :meta {:arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s.", :end-column 17, :end-line 8370, :column 7, :line 8370, :file "cljs/core.cljs"}, :name cljs.core/re-matches, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8370, :end-line 8370, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s.", :test true}, pr-writer-impl {:protocol-inline nil, :meta {:arglists (quote ([obj writer opts])), :private true, :end-column 22, :end-line 8469, :column 8, :line 8469, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-writer-impl, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8469, :end-line 8469, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :test true}, array-map {:protocol-inline nil, :meta {:arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :end-column 16, :end-line 7438, :column 7, :line 7438, :file "cljs/core.cljs"}, :name cljs.core/array-map, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7438, :end-line 7438, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :test true}, ITransientSet {:meta {:protocol-info {:methods {-disjoin! [[tcoll v]]}}, :protocol-symbol true, :doc "Protocol for adding set functionality to a transient collection.", :end-column 27, :end-line 579, :column 14, :line 579, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column 1, :line 579, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 579, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection.", :test true}, ITER_SYMBOL {:meta {:end-column 19, :end-line 234, :column 8, :line 234, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 234, :column 3, :end-line 234, :end-column 19, :test true, :name cljs.core/ITER_SYMBOL}, unchecked-byte {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 29, :end-line 2211, :column 15, :line 2211, :file "cljs/core.cljs"}, :name cljs.core/unchecked-byte, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2211, :ret-tag number, :end-line 2211, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ArrayNode {:meta {:declared true, :end-column 19, :end-line 5952, :column 10, :line 5952, :file "cljs/core.cljs"}, :num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 6165, :record false, :declared true, :end-line 6165, :skip-protocol-flag nil, :test true}, ->ChunkedSeq {:protocol-inline nil, :meta {:arglists (quote ([vec node i off meta __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 20, :end-line 4782, :column 10, :line 4782, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 6}), :line 4782, :end-line 4782, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, every-pred {:protocol-inline nil, :meta {:arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :end-column 17, :end-line 3942, :column 7, :line 3942, :file "cljs/core.cljs"}, :name cljs.core/every-pred, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3942, :end-line 3942, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :test true}, keys {:protocol-inline nil, :meta {:arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys.", :end-column 11, :end-line 7533, :column 7, :line 7533, :file "cljs/core.cljs"}, :name cljs.core/keys, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/KeySeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7533, :end-line 7533, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys.", :test true}, missing-protocol {:protocol-inline nil, :meta {:arglists (quote ([proto obj])), :end-column 23, :end-line 212, :column 7, :line 212, :file "cljs/core.cljs"}, :name cljs.core/missing-protocol, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag js/Error, :variadic false, :max-fixed-arity 2}), :line 212, :end-line 212, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj])), :test true}, load-file {:protocol-inline nil, :meta {:arglists (quote ([file])), :end-column 16, :end-line 227, :column 7, :line 227, :file "cljs/core.cljs"}, :name cljs.core/load-file, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 227, :end-line 227, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file])), :test true}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5632, :record false, :end-line 5632, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :tag boolean, :end-column 25, :end-line 1894, :column 16, :line 1894, :file "cljs/core.cljs"}, :name cljs.core/distinct?, :variadic true, :file "cljs/core.cljs", :end-column 25, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1894, :ret-tag boolean, :end-line 1894, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :test true}, never-equiv {:meta {:private true, :end-column 27, :end-line 5287, :column 16, :line 5287, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 5287, :column 1, :end-line 5287, :end-column 27, :private true, :test true, :name cljs.core/never-equiv}, ->t7430 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :arglists (quote ([nil-iter meta7431])), :factory :positional, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :anonymous true}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7430, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta7431]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t7430, :variadic false, :max-fixed-arity 2}), :line 3347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7431])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3415, :record false, :end-line 3415, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 30, :end-line 2213, :column 15, :line 2213, :file "cljs/core.cljs"}, :name cljs.core/unchecked-short, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2213, :ret-tag number, :end-line 2213, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ->Range {:protocol-inline nil, :meta {:arglists (quote ([meta start end step __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 15, :end-line 8113, :column 10, :line 8113, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 5}), :line 8113, :end-line 8113, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, methods {:protocol-inline nil, :meta {:arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :end-column 14, :end-line 9451, :column 7, :line 9451, :file "cljs/core.cljs"}, :name cljs.core/methods, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9451, :end-line 9451, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :test true}, odd? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer", :tag boolean, :end-column 20, :end-line 3613, :column 16, :line 3613, :file "cljs/core.cljs"}, :name cljs.core/odd?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3613, :ret-tag boolean, :end-line 3613, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer", :test true}, ->ArrayChunk {:protocol-inline nil, :meta {:arglists (quote ([arr off end])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :end-column 20, :end-line 2917, :column 10, :line 2917, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2917, :end-line 2917, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, lazy-transformer {:protocol-inline nil, :meta {:arglists (quote ([stepper])), :end-column 23, :end-line 3412, :column 7, :line 3412, :file "cljs/core.cljs"}, :name cljs.core/lazy-transformer, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 1}), :line 3412, :end-line 3412, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper])), :test true}, ci-reduce {:protocol-inline nil, :meta {:arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :private true, :end-column 17, :end-line 1160, :column 8, :line 1160, :file "cljs/core.cljs"}, :private true, :name cljs.core/ci-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 1160, :end-line 1160, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :test true}, *3 {:meta {:doc "bound in a repl thread to the third most recent value printed", :end-column 5, :end-line 128, :column 3, :line 128, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 126, :column 1, :end-line 128, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :test true, :name cljs.core/*3}, -get-method {:protocol-inline nil, :meta {:arglists (quote ([mf dispatch-val])), :doc nil, :protocol cljs.core/IMultiFn, :end-column 15, :end-line 9243, :column 4, :line 9243, :file "cljs/core.cljs"}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9238, :end-line 9243, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil, :test true}, ->Var {:protocol-inline nil, :meta {:arglists (quote ([val sym _meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :end-column 13, :end-line 859, :column 10, :line 859, :file "cljs/core.cljs"}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/->Var, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Var, :variadic false, :max-fixed-arity 3}), :line 859, :end-line 859, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}, :test true}, frequencies {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :end-column 18, :end-line 8277, :column 7, :line 8277, :file "cljs/core.cljs"}, :name cljs.core/frequencies, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 8277, :end-line 8277, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :test true}, reduceable? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce", :tag boolean, :end-column 27, :end-line 1770, :column 16, :line 1770, :file "cljs/core.cljs"}, :name cljs.core/reduceable?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1770, :ret-tag boolean, :end-line 1770, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce", :test true}, string-hash-cache {:meta {:end-column 23, :end-line 723, :column 6, :line 723, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 723, :column 1, :end-line 723, :end-column 23, :test true, :name cljs.core/string-hash-cache}, rsubseq {:protocol-inline nil, :meta {:arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-column 14, :end-line 8087, :column 7, :line 8087, :file "cljs/core.cljs"}, :name cljs.core/rsubseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 8087, :end-line 8087, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, inc {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns a number one greater than num.", :end-column 10, :end-line 1120, :column 7, :line 1120, :file "cljs/core.cljs"}, :name cljs.core/inc, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1120, :end-line 1120, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num.", :test true}, type->str {:protocol-inline nil, :meta {:arglists (quote ([ty])), :end-column 16, :end-line 221, :column 7, :line 221, :file "cljs/core.cljs"}, :name cljs.core/type->str, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 221, :end-line 221, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty])), :test true}, obj-clone {:protocol-inline nil, :meta {:arglists (quote ([obj ks])), :private true, :end-column 17, :end-line 5339, :column 8, :line 5339, :file "cljs/core.cljs"}, :private true, :name cljs.core/obj-clone, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 2}), :line 5339, :end-line 5339, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks])), :test true}, get-method {:protocol-inline nil, :meta {:arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :end-column 17, :end-line 9455, :column 7, :line 9455, :file "cljs/core.cljs"}, :name cljs.core/get-method, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9455, :end-line 9455, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :test true}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:arglists (quote ([i cnt])), :private true, :end-column 34, :end-line 4487, :column 8, :line 4487, :file "cljs/core.cljs"}, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 4487, :end-line 4487, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt])), :test true}, es6-entries-iterator {:protocol-inline nil, :meta {:arglists (quote ([coll])), :end-column 27, :end-line 5469, :column 7, :line 5469, :file "cljs/core.cljs"}, :name cljs.core/es6-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5469, :end-line 5469, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, bit-clear {:protocol-inline nil, :meta {:arglists (quote ([x n])), :doc "Clear bit at index n", :end-column 16, :end-line 2373, :column 7, :line 2373, :file "cljs/core.cljs"}, :name cljs.core/bit-clear, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2373, :end-line 2373, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n", :test true}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8113, :record false, :end-line 8113, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-column 13, :end-line 4245, :column 7, :line 4245, :file "cljs/core.cljs"}, :name cljs.core/filter, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4245, :end-line 4245, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:arglists (quote ([meta stack ascending? cnt __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 30, :end-line 6766, :column 10, :line 6766, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 5}), :line 6766, :end-line 6766, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-array-node-seq {:protocol-inline nil, :meta {:arglists (quote ([nodes] [meta nodes i s])), :private true, :end-column 29, :end-line 6489, :column 8, :line 6489, :file "cljs/core.cljs"}, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 4}), :line 6489, :end-line 6489, :max-fixed-arity 4, :fn-var true, :arglists (quote ([nodes] [meta nodes i s])), :test true}, -assoc-n! {:protocol-inline nil, :meta {:arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n.", :protocol cljs.core/ITransientVector, :tag clj, :end-column 18, :end-line 574, :column 9, :line 574, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 572, :ret-tag clj, :end-line 574, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n.", :test true}, IWithMeta {:meta {:protocol-info {:methods {-with-meta [[o meta]]}}, :protocol-symbol true, :doc "Protocol for adding metadata to an object.", :end-column 23, :end-line 452, :column 14, :line 452, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column 1, :line 452, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 452, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/t20893 cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/t20896 cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding metadata to an object.", :test true}, list {:protocol-inline nil, :meta {:arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :end-column 11, :end-line 2673, :column 7, :line 2673, :file "cljs/core.cljs"}, :name cljs.core/list, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag not-native, :variadic true, :max-fixed-arity 0}), :line 2673, :end-line 2673, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :test true}, + {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :tag number, :end-column 16, :end-line 2100, :column 15, :line 2100, :file "cljs/core.cljs"}, :name cljs.core/+, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2100, :ret-tag number, :end-line 2100, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1234, :record false, :end-line 1234, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :end-column 17, :end-line 8231, :column 7, :line 8231, :file "cljs/core.cljs"}, :name cljs.core/split-with, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 8231, :end-line 8231, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :test true}, ->VectorNode {:protocol-inline nil, :meta {:arglists (quote ([edit arr])), :factory :positional, :skip-protocol-flag nil, :protocols #{}, :end-column 20, :end-line 4441, :column 10, :line 4441, :file "cljs/core.cljs"}, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 2}), :line 4441, :end-line 4441, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil, :test true}, aset {:protocol-inline nil, :meta {:arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :end-column 11, :end-line 276, :column 7, :line 276, :file "cljs/core.cljs"}, :name cljs.core/aset, :variadic true, :file "cljs/core.cljs", :end-column 11, :method-params ([array i val] [array idx idx2 idxv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic true, :max-fixed-arity 3}), :line 276, :end-line 276, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :test true}, int-rotate-left {:protocol-inline nil, :meta {:arglists (quote ([x n])), :tag number, :end-column 30, :end-line 658, :column 15, :line 658, :file "cljs/core.cljs"}, :name cljs.core/int-rotate-left, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 658, :ret-tag number, :end-line 658, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n])), :test true}, keyword {:protocol-inline nil, :meta {:arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-column 14, :end-line 2817, :column 7, :line 2817, :file "cljs/core.cljs"}, :name cljs.core/keyword, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Keyword clj-nil}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 2}), :line 2817, :end-line 2817, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :test true}, ->Cons {:protocol-inline nil, :meta {:arglists (quote ([meta first rest __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 14, :end-line 2690, :column 10, :line 2690, :file "cljs/core.cljs"}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4}), :line 2690, :end-line 2690, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-tree-map-seq {:protocol-inline nil, :meta {:arglists (quote ([tree ascending? cnt])), :private true, :end-column 27, :end-line 6819, :column 8, :line 6819, :file "cljs/core.cljs"}, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 3}), :line 6819, :end-line 6819, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt])), :test true}, ICollection {:meta {:protocol-info {:methods {-conj [[coll o]]}}, :protocol-symbol true, :doc "Protocol for adding to a collection.", :end-column 25, :end-line 353, :column 14, :line 353, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column 1, :line 353, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 353, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection.", :test true}, multi-stepper {:protocol-inline nil, :meta {:arglists (quote ([xform iters] [xform iters nexts])), :end-column 20, :end-line 3469, :column 7, :line 3469, :file "cljs/core.cljs"}, :name cljs.core/multi-stepper, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3469, :end-line 3469, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters] [xform iters nexts])), :test true}, chars {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 12, :end-line 2320, :column 7, :line 2320, :file "cljs/core.cljs"}, :name cljs.core/chars, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2320, :end-line 2320, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, str {:protocol-inline nil, :meta {:arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :end-column 10, :end-line 2458, :column 7, :line 2458, :file "cljs/core.cljs"}, :name cljs.core/str, :variadic true, :file "cljs/core.cljs", :end-column 10, :method-params ([] [x] [x ys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 0} {:tag #{any string}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 2458, :end-line 2458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :test true}, next {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :tag seq, :end-column 16, :end-line 977, :column 12, :line 977, :file "cljs/core.cljs"}, :name cljs.core/next, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 977, :ret-tag seq, :end-line 977, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :test true}, ASeq {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker protocol indicating an array sequence.", :end-column 18, :end-line 370, :column 14, :line 370, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 370, :protocol-info {:methods {}}, :info nil, :end-line 370, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence.", :test true}, pr-seq-writer {:protocol-inline nil, :meta {:arglists (quote ([objs writer opts])), :end-column 20, :end-line 8546, :column 7, :line 8546, :file "cljs/core.cljs"}, :name cljs.core/pr-seq-writer, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 3}), :line 8546, :end-line 8546, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts])), :test true}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3380, :record false, :end-line 3380, :skip-protocol-flag nil}, IFn {:meta {:protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :protocol-symbol true, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :end-column 17, :end-line 309, :column 14, :line 309, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column 1, :line 309, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 309, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :test true}, regexp? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance.", :end-column 14, :end-line 8365, :column 7, :line 8365, :file "cljs/core.cljs"}, :name cljs.core/regexp?, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8365, :end-line 8365, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance.", :test true}, hash-map {:protocol-inline nil, :meta {:arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :end-column 15, :end-line 7429, :column 7, :line 7429, :file "cljs/core.cljs"}, :name cljs.core/hash-map, :variadic true, :file "cljs/core.cljs", :end-column 15, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic true, :max-fixed-arity 0}), :line 7429, :end-line 7429, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :test true}, underive {:protocol-inline nil, :meta {:arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-column 15, :end-line 9165, :column 7, :line 9165, :file "cljs/core.cljs"}, :name cljs.core/underive, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 9165, :end-line 9165, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, array-copy {:protocol-inline nil, :meta {:arglists (quote ([from i to j len])), :private true, :end-column 18, :end-line 1812, :column 8, :line 1812, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-copy, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1812, :end-line 1812, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, obj-map-compare-keys {:protocol-inline nil, :meta {:arglists (quote ([a b])), :private true, :end-column 28, :end-line 5317, :column 8, :line 5317, :file "cljs/core.cljs"}, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5317, :end-line 5317, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -reset! {:protocol-inline nil, :meta {:arglists (quote ([o new-value])), :doc "Sets the value of o to new-value.", :protocol cljs.core/IReset, :end-column 11, :end-line 619, :column 4, :line 619, :file "cljs/core.cljs"}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 617, :end-line 619, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value.", :test true}, -rest {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :protocol cljs.core/ISeq, :tag clj, :end-column 14, :end-line 377, :column 9, :line 377, :file "cljs/core.cljs"}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 373, :ret-tag clj, :end-line 377, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :test true}, nil-iter {:protocol-inline nil, :meta {:arglists (quote ([])), :end-column 15, :end-line 3346, :column 7, :line 3346, :file "cljs/core.cljs"}, :name cljs.core/nil-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/t20896, :variadic false, :max-fixed-arity 0}), :line 3346, :end-line 3346, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, pr-writer {:protocol-inline nil, :meta {:arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :private true, :end-column 17, :end-line 8537, :column 8, :line 8537, :file "cljs/core.cljs"}, :private true, :name cljs.core/pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8537, :end-line 8537, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :test true}, false? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise.", :tag boolean, :end-column 22, :end-line 1832, :column 16, :line 1832, :file "cljs/core.cljs"}, :name cljs.core/false?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1832, :ret-tag boolean, :end-line 1832, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise.", :test true}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 4538, :record false, :end-line 4538, :skip-protocol-flag nil}, *print-readably* {:meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :dynamic true, :end-column 19, :end-line 61, :column 3, :line 61, :file "cljs/core.cljs"}, :name cljs.core/*print-readably*, :file "cljs/core.cljs", :end-column 19, :column 1, :dynamic true, :line 55, :end-line 61, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :test true}, ints {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 11, :end-line 2322, :column 7, :line 2322, :file "cljs/core.cljs"}, :name cljs.core/ints, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2322, :end-line 2322, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, some-fn {:protocol-inline nil, :meta {:arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :end-column 14, :end-line 3981, :column 7, :line 3981, :file "cljs/core.cljs"}, :name cljs.core/some-fn, :variadic true, :file "cljs/core.cljs", :end-column 14, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3981, :end-line 3981, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :test true}, *flush-on-newline* {:meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :dynamic true, :end-column 21, :end-line 46, :column 3, :line 46, :file "cljs/core.cljs"}, :name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :end-column 21, :column 1, :dynamic true, :line 41, :end-line 46, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :test true}, to-array {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Naive impl of to-array as a start.", :end-column 15, :end-line 3037, :column 7, :line 3037, :file "cljs/core.cljs"}, :name cljs.core/to-array, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 3037, :end-line 3037, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start.", :test true}, build-subvec {:protocol-inline nil, :meta {:arglists (quote ([meta v start end __hash])), :private true, :end-column 20, :end-line 4972, :column 8, :line 4972, :file "cljs/core.cljs"}, :private true, :name cljs.core/build-subvec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4972, :end-line 4972, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :test true}, list? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x implements IList", :tag boolean, :end-column 21, :end-line 2747, :column 16, :line 2747, :file "cljs/core.cljs"}, :name cljs.core/list?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2747, :ret-tag boolean, :end-line 2747, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList", :test true}, tree-map-remove {:protocol-inline nil, :meta {:arglists (quote ([comp tree k found])), :private true, :end-column 23, :end-line 7248, :column 8, :line 7248, :file "cljs/core.cljs"}, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 7248, :end-line 7248, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found])), :test true}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6271, :record false, :end-line 6271, :skip-protocol-flag nil}, array? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x is a JavaScript array.", :tag boolean, :end-column 22, :end-line 153, :column 16, :line 153, :file "cljs/core.cljs"}, :name cljs.core/array?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean any}, :variadic false, :max-fixed-arity 1}), :line 153, :ret-tag boolean, :end-line 153, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array.", :test true}, prefers* {:protocol-inline nil, :meta {:arglists (quote ([x y prefer-table])), :private true, :end-column 16, :end-line 9191, :column 8, :line 9191, :file "cljs/core.cljs"}, :private true, :name cljs.core/prefers*, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 9191, :end-line 9191, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, clone {:protocol-inline nil, :meta {:arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable.", :end-column 12, :end-line 920, :column 7, :line 920, :file "cljs/core.cljs"}, :name cljs.core/clone, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 920, :end-line 920, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable.", :test true}, scan-array {:protocol-inline nil, :meta {:arglists (quote ([incr k array])), :private true, :end-column 18, :end-line 5303, :column 8, :line 5303, :file "cljs/core.cljs"}, :private true, :name cljs.core/scan-array, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5303, :end-line 5303, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array])), :test true}, bit-not {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Bitwise complement", :end-column 14, :end-line 2383, :column 7, :line 2383, :file "cljs/core.cljs"}, :name cljs.core/bit-not, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2383, :end-line 2383, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement", :test true}, quote-string {:protocol-inline nil, :meta {:arglists (quote ([s])), :private true, :end-column 29, :end-line 8460, :column 17, :line 8460, :file "cljs/core.cljs"}, :private true, :name cljs.core/quote-string, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8460, :end-line 8460, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, byte {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 19, :end-line 2197, :column 15, :line 2197, :file "cljs/core.cljs"}, :name cljs.core/byte, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2197, :ret-tag number, :end-line 2197, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, max {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :tag number, :end-column 18, :end-line 2183, :column 15, :line 2183, :file "cljs/core.cljs"}, :name cljs.core/max, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2183, :ret-tag number, :end-line 2183, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :test true}, IComparable {:meta {:protocol-info {:methods {-compare [[x y]]}}, :protocol-symbol true, :doc "Protocol for values that can be compared.", :end-column 25, :end-line 584, :column 14, :line 584, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column 1, :line 584, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 584, :impls #{js/Date cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID}, :doc "Protocol for values that can be compared.", :test true}, == {:protocol-inline nil, :meta {:arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :tag boolean, :end-column 18, :end-line 2420, :column 16, :line 2420, :file "cljs/core.cljs"}, :name cljs.core/==, :variadic true, :file "cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2420, :ret-tag boolean, :end-line 2420, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :test true}, parents {:protocol-inline nil, :meta {:arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-column 14, :end-line 9106, :column 7, :line 9106, :file "cljs/core.cljs"}, :name cljs.core/parents, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 9106, :end-line 9106, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, count {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :end-column 12, :end-line 1449, :column 7, :line 1449, :file "cljs/core.cljs"}, :name cljs.core/count, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1449, :end-line 1449, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :test true}, -disjoin! {:protocol-inline nil, :meta {:arglists (quote ([tcoll v])), :doc "Returns tcoll without v.", :protocol cljs.core/ITransientSet, :tag clj, :end-column 18, :end-line 581, :column 9, :line 581, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 579, :ret-tag clj, :end-line 581, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v.", :test true}, *loaded-libs* {:meta {:dynamic true, :end-column 33, :end-line 99, :column 20, :line 99, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 99, :column 1, :end-line 99, :end-column 33, :dynamic true, :test true, :name cljs.core/*loaded-libs*}, ->TransientHashMap {:protocol-inline nil, :meta {:arglists (quote ([edit root count has-nil? nil-val])), :factory :positional, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :end-column 26, :end-line 6654, :column 10, :line 6654, :file "cljs/core.cljs"}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashMap, :variadic false, :max-fixed-arity 5}), :line 6654, :end-line 6654, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ArrayChunk {:meta {:declared true, :end-column 20, :end-line 2898, :column 10, :line 2898, :file "cljs/core.cljs"}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 2917, :record false, :declared true, :end-line 2917, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, sorted-map-by {:protocol-inline nil, :meta {:arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :end-column 20, :end-line 7466, :column 7, :line 7466, :file "cljs/core.cljs"}, :name cljs.core/sorted-map-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :method-params ([comparator keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMap, :variadic true, :max-fixed-arity 1}), :line 7466, :end-line 7466, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :test true}, apply {:protocol-inline nil, :meta {:arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :end-column 12, :end-line 3271, :column 7, :line 3271, :file "cljs/core.cljs"}, :name cljs.core/apply, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([f args] [f x args] [f x y args] [f x y z args] [f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic true, :max-fixed-arity 5}), :line 3271, :end-line 3271, :max-fixed-arity 5, :fn-var true, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :test true}, get-global-hierarchy {:protocol-inline nil, :meta {:arglists (quote ([])), :private true, :end-column 28, :end-line 9078, :column 8, :line 9078, :file "cljs/core.cljs"}, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 9078, :end-line 9078, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, add-to-string-hash-cache {:protocol-inline nil, :meta {:arglists (quote ([k])), :end-column 31, :end-line 738, :column 7, :line 738, :file "cljs/core.cljs"}, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 738, :end-line 738, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, clj->js {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js.", :end-column 14, :end-line 8958, :column 7, :line 8958, :file "cljs/core.cljs"}, :name cljs.core/clj->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil object any array string clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8958, :end-line 8958, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js.", :test true}, TransientArrayMap {:meta {:declared true, :end-column 27, :end-line 5560, :column 10, :line 5560, :file "cljs/core.cljs"}, :num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 5812, :record false, :declared true, :end-line 5812, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->TransientVector {:protocol-inline nil, :meta {:arglists (quote ([cnt shift root tail])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :end-column 25, :end-line 5049, :column 10, :line 5049, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientVector, :variadic false, :max-fixed-arity 4}), :line 5049, :end-line 5049, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, IChunkedNext {:meta {:protocol-info {:methods {-chunked-next [[coll]]}}, :protocol-symbol true, :doc "Protocol for accessing the chunks of a collection.", :end-column 26, :end-line 602, :column 14, :line 602, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column 1, :line 602, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 602, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing the chunks of a collection.", :test true}, interpose {:protocol-inline nil, :meta {:arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :end-column 16, :end-line 4200, :column 7, :line 4200, :file "cljs/core.cljs"}, :name cljs.core/interpose, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4200, :end-line 4200, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :test true}, ->BlackNode {:protocol-inline nil, :meta {:arglists (quote ([key val left right __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :end-column 19, :end-line 6925, :column 10, :line 6925, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BlackNode, :variadic false, :max-fixed-arity 5}), :line 6925, :end-line 6925, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, deref {:meta {:declared true, :end-column 78, :end-line 5893, :column 73, :line 5893, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 5893, :column 1, :end-line 5893, :end-column 78, :declared true, :test true, :name cljs.core/deref}, pv-aget {:protocol-inline nil, :meta {:arglists (quote ([node idx])), :private true, :end-column 15, :end-line 4446, :column 8, :line 4446, :file "cljs/core.cljs"}, :private true, :name cljs.core/pv-aget, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4446, :end-line 4446, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx])), :test true}, assoc {:protocol-inline nil, :meta {:arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :end-column 12, :end-line 1606, :column 7, :line 1606, :file "cljs/core.cljs"}, :name cljs.core/assoc, :variadic true, :file "cljs/core.cljs", :end-column 12, :method-params ([coll k v] [coll k v kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 1606, :end-line 1606, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :test true}, transient {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :end-column 16, :end-line 3200, :column 7, :line 3200, :file "cljs/core.cljs"}, :name cljs.core/transient, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 3200, :end-line 3200, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :test true}, -disjoin {:protocol-inline nil, :meta {:arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v.", :protocol cljs.core/ISet, :tag clj, :end-column 17, :end-line 421, :column 9, :line 421, :file "cljs/core.cljs"}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 419, :ret-tag clj, :end-line 421, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v.", :test true}, chunk-cons {:protocol-inline nil, :meta {:arglists (quote ([chunk rest])), :end-column 17, :end-line 3013, :column 7, :line 3013, :file "cljs/core.cljs"}, :name cljs.core/chunk-cons, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/ChunkedCons}, :variadic false, :max-fixed-arity 2}), :line 3013, :end-line 3013, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest])), :test true}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3365, :record false, :end-line 3365, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred.", :end-column 17, :end-line 9563, :column 7, :line 9563, :file "cljs/core.cljs"}, :name cljs.core/comparator, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 9563, :end-line 9563, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred.", :test true}, sorted-map {:protocol-inline nil, :meta {:arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :end-column 17, :end-line 7457, :column 7, :line 7457, :file "cljs/core.cljs"}, :name cljs.core/sorted-map, :variadic true, :file "cljs/core.cljs", :end-column 17, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7457, :end-line 7457, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :test true}, drop-while {:protocol-inline nil, :meta {:arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :end-column 17, :end-line 4129, :column 7, :line 4129, :file "cljs/core.cljs"}, :name cljs.core/drop-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4129, :end-line 4129, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :test true}, IWriter {:meta {:protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :protocol-symbol true, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :end-column 21, :end-line 518, :column 14, :line 518, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column 1, :line 518, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 518, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :test true}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7476, :record false, :end-line 7476, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:arglists (quote ([d])), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :tag boolean, :end-column 25, :end-line 8862, :column 16, :line 8862, :file "cljs/core.cljs"}, :name cljs.core/realized?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8862, :ret-tag boolean, :end-line 8862, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :test true}, array-map-index-of-keyword? {:protocol-inline nil, :meta {:arglists (quote ([arr m k])), :private true, :end-column 35, :end-line 5495, :column 8, :line 5495, :file "cljs/core.cljs"}, :private true, :name cljs.core/array-map-index-of-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 35, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5495, :end-line 5495, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, *print-fn* {:protocol-inline nil, :meta {:dynamic true, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :end-column 13, :end-line 33, :column 3, :line 33, :file "cljs/core.cljs"}, :name cljs.core/*print-fn*, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 1}), :dynamic true, :line 29, :end-line 33, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :test true}, compare {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :tag number, :end-column 22, :end-line 1912, :column 15, :line 1912, :file "cljs/core.cljs"}, :name cljs.core/compare, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 1912, :ret-tag number, :end-line 1912, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :test true}, complement {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :tag boolean, :end-column 26, :end-line 3617, :column 16, :line 3617, :file "cljs/core.cljs"}, :name cljs.core/complement, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3617, :ret-tag boolean, :end-line 3617, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :test true}, lookup-sentinel {:meta {:private true, :end-column 31, :end-line 1830, :column 16, :line 1830, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 1830, :column 1, :end-line 1830, :end-column 31, :private true, :test true, :name cljs.core/lookup-sentinel}, -assoc! {:protocol-inline nil, :meta {:arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :protocol cljs.core/ITransientAssociative, :tag clj, :end-column 16, :end-line 563, :column 9, :line 563, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 561, :ret-tag clj, :end-line 563, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :test true}, *print-dup* {:meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :dynamic true, :end-column 14, :end-line 77, :column 3, :line 77, :file "cljs/core.cljs"}, :name cljs.core/*print-dup*, :file "cljs/core.cljs", :end-column 14, :column 1, :dynamic true, :line 71, :end-line 77, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :test true}, string-iter {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 18, :end-line 3362, :column 7, :line 3362, :file "cljs/core.cljs"}, :name cljs.core/string-iter, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 1}), :line 3362, :end-line 3362, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -key->js {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :protocol cljs.core/IEncodeJS, :end-column 12, :end-line 8943, :column 4, :line 8943, :file "cljs/core.cljs"}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8941, :end-line 8943, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :test true}, IDeref {:meta {:protocol-info {:methods {-deref [[o]]}}, :protocol-symbol true, :doc "Protocol for adding dereference functionality to a reference.", :end-column 20, :end-line 439, :column 14, :line 439, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column 1, :line 439, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 439, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference.", :test true}, sequence {:protocol-inline nil, :meta {:arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :end-column 15, :end-line 3561, :column 7, :line 3561, :file "cljs/core.cljs"}, :name cljs.core/sequence, :variadic true, :file "cljs/core.cljs", :end-column 15, :method-params ([coll] [xform coll] [xform coll colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 3561, :end-line 3561, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :test true}, constantly {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x.", :end-column 17, :end-line 3627, :column 7, :line 3627, :file "cljs/core.cljs"}, :name cljs.core/constantly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3627, :end-line 3627, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x.", :test true}, ->RangedIterator {:protocol-inline nil, :meta {:arglists (quote ([i base arr v start end])), :factory :positional, :skip-protocol-flag nil, :protocols #{cljs.core/Object}, :end-column 24, :end-line 4538, :column 10, :line 4538, :file "cljs/core.cljs"}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 6}), :line 4538, :end-line 4538, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil, :test true}, chunked-seq {:protocol-inline nil, :meta {:arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :end-column 18, :end-line 4858, :column 7, :line 4858, :file "cljs/core.cljs"}, :name cljs.core/chunked-seq, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 5}), :line 4858, :end-line 4858, :max-fixed-arity 5, :fn-var true, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :test true}, ISorted {:meta {:protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :protocol-symbol true, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :end-column 21, :end-line 501, :column 14, :line 501, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column 1, :line 501, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 501, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :test true}, make-array {:protocol-inline nil, :meta {:arglists (quote ([size] [type size])), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure.", :tag array, :end-column 24, :end-line 238, :column 14, :line 238, :file "cljs/core.cljs"}, :name cljs.core/make-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 238, :ret-tag array, :end-line 238, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([size] [type size])), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure.", :test true}, shorts {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 13, :end-line 2321, :column 7, :line 2321, :file "cljs/core.cljs"}, :name cljs.core/shorts, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2321, :end-line 2321, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, *unchecked-if* {:meta {:end-column 20, :end-line 18, :column 6, :line 18, :file "cljs/core.cljs"}, :file "cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 20, :test true, :name cljs.core/*unchecked-if*}, ->RSeq {:protocol-inline nil, :meta {:arglists (quote ([ci i meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 14, :end-line 1330, :column 10, :line 1330, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RSeq, :variadic false, :max-fixed-arity 3}), :line 1330, :end-line 1330, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, enable-console-print! {:protocol-inline nil, :meta {:arglists (quote ([])), :doc "Set *print-fn* to console.log", :end-column 28, :end-line 110, :column 7, :line 110, :file "cljs/core.cljs"}, :name cljs.core/enable-console-print!, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 110, :end-line 110, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log", :test true}, -flush {:protocol-inline nil, :meta {:arglists (quote ([writer])), :doc "Flush writer.", :protocol cljs.core/IWriter, :end-column 10, :end-line 522, :column 4, :line 522, :file "cljs/core.cljs"}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 518, :end-line 522, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer.", :test true}, completing {:protocol-inline nil, :meta {:arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :end-column 17, :end-line 2071, :column 7, :line 2071, :file "cljs/core.cljs"}, :name cljs.core/completing, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2}), :line 2071, :end-line 2071, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :test true}, unchecked-negate-int {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 27, :end-line 2271, :column 7, :line 2271, :file "cljs/core.cljs"}, :name cljs.core/unchecked-negate-int, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2271, :end-line 2271, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->PersistentVector {:protocol-inline nil, :meta {:arglists (quote ([meta cnt shift root tail __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :end-column 26, :end-line 4560, :column 10, :line 4560, :file "cljs/core.cljs"}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentVector, :variadic false, :max-fixed-arity 6}), :line 4560, :end-line 4560, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, equiv-sequential {:protocol-inline nil, :meta {:arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :private true, :end-column 24, :end-line 2480, :column 8, :line 2480, :file "cljs/core.cljs"}, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2480, :end-line 2480, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :test true}, hash-unordered-coll {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :tag number, :end-column 34, :end-line 1067, :column 15, :line 1067, :file "cljs/core.cljs"}, :name cljs.core/hash-unordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1067, :ret-tag number, :end-line 1067, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, repeat {:protocol-inline nil, :meta {:arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :end-column 13, :end-line 4165, :column 7, :line 4165, :file "cljs/core.cljs"}, :name cljs.core/repeat, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 4165, :end-line 4165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :test true}, unchecked-inc {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 20, :end-line 2248, :column 7, :line 2248, :file "cljs/core.cljs"}, :name cljs.core/unchecked-inc, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2248, :end-line 2248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, nthnext {:protocol-inline nil, :meta {:arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0.", :end-column 14, :end-line 2448, :column 7, :line 2448, :file "cljs/core.cljs"}, :name cljs.core/nthnext, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 2448, :end-line 2448, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0.", :test true}, preserving-reduced {:protocol-inline nil, :meta {:arglists (quote ([rf])), :private true, :end-column 26, :end-line 8867, :column 8, :line 8867, :file "cljs/core.cljs"}, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8867, :end-line 8867, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :test true}, get-validator {:protocol-inline nil, :meta {:arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom.", :end-column 20, :end-line 3879, :column 7, :line 3879, :file "cljs/core.cljs"}, :name cljs.core/get-validator, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3879, :end-line 3879, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom.", :test true}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3353, :record false, :end-line 3353, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:arglists (quote ([n])), :doc "Returns true if x is a JavaScript number.", :tag boolean, :end-column 23, :end-line 160, :column 16, :line 160, :file "cljs/core.cljs"}, :name cljs.core/number?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 160, :ret-tag boolean, :end-line 160, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if x is a JavaScript number.", :test true}, -conj! {:protocol-inline nil, :meta {:arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll.", :protocol cljs.core/ITransientCollection, :tag clj, :end-column 15, :end-line 556, :column 9, :line 556, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 554, :ret-tag clj, :end-line 556, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll.", :test true}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:arglists (quote ([arr i _meta])), :factory :positional, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :end-column 31, :end-line 5562, :column 10, :line 5562, :file "cljs/core.cljs"}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapSeq, :variadic false, :max-fixed-arity 3}), :line 5562, :end-line 5562, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, chunk-next {:protocol-inline nil, :meta {:arglists (quote ([s])), :end-column 17, :end-line 3030, :column 7, :line 3030, :file "cljs/core.cljs"}, :name cljs.core/chunk-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq any}, :variadic false, :max-fixed-arity 1}), :line 3030, :end-line 3030, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8005, :record false, :end-line 8005, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:arglists (quote ([& objs])), :doc "print to a string, returning it", :end-column 16, :end-line 8612, :column 7, :line 8612, :file "cljs/core.cljs"}, :name cljs.core/print-str, :variadic true, :file "cljs/core.cljs", :end-column 16, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic true, :max-fixed-arity 0}), :line 8612, :end-line 8612, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "print to a string, returning it", :test true}, not-any? {:protocol-inline nil, :meta {:arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :tag boolean, :end-column 24, :end-line 3602, :column 16, :line 3602, :file "cljs/core.cljs"}, :name cljs.core/not-any?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3602, :ret-tag boolean, :end-line 3602, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :test true}, into-array {:protocol-inline nil, :meta {:arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :tag array, :end-column 24, :end-line 290, :column 14, :line 290, :file "cljs/core.cljs"}, :name cljs.core/into-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2}), :line 290, :ret-tag array, :end-line 290, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :test true}, -hash {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns the hash code of o.", :protocol cljs.core/IHash, :end-column 9, :end-line 479, :column 4, :line 479, :file "cljs/core.cljs"}, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 477, :end-line 479, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o.", :test true}, -dissoc! {:protocol-inline nil, :meta {:arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key.", :protocol cljs.core/ITransientMap, :tag clj, :end-column 17, :end-line 569, :column 9, :line 569, :file "cljs/core.cljs"}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 567, :ret-tag clj, :end-line 569, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key.", :test true}, ->Reduced {:protocol-inline nil, :meta {:arglists (quote ([val])), :factory :positional, :skip-protocol-flag #{cljs.core/IDeref}, :protocols #{cljs.core/IDeref}, :end-column 17, :end-line 1126, :column 10, :line 1126, :file "cljs/core.cljs"}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 1126, :end-line 1126, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, chunk-buffer {:protocol-inline nil, :meta {:arglists (quote ([capacity])), :end-column 19, :end-line 2914, :column 7, :line 2914, :file "cljs/core.cljs"}, :name cljs.core/chunk-buffer, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 1}), :line 2914, :end-line 2914, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity])), :test true}, seqable? {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Return true if s satisfies ISeqable", :tag boolean, :end-column 24, :end-line 1852, :column 16, :line 1852, :file "cljs/core.cljs"}, :name cljs.core/seqable?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1852, :ret-tag boolean, :end-line 1852, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable", :test true}, symbol? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Return true if x is a Symbol", :tag boolean, :end-column 23, :end-line 792, :column 16, :line 792, :file "cljs/core.cljs"}, :name cljs.core/symbol?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 792, :ret-tag boolean, :end-line 792, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol", :test true}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:arglists (quote ([in])), :tag number, :end-column 38, :end-line 704, :column 15, :line 704, :file "cljs/core.cljs"}, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 704, :ret-tag number, :end-line 704, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, unchecked-char {:protocol-inline nil, :meta {:arglists (quote ([x])), :tag number, :end-column 29, :end-line 2212, :column 15, :line 2212, :file "cljs/core.cljs"}, :name cljs.core/unchecked-char, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2212, :ret-tag number, :end-line 2212, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5280, :record false, :end-line 5280, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :meta {:arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :doc nil, :protocol cljs.core/IFn, :end-column 11, :end-line 313, :column 4, :line 313, :file "cljs/core.cljs"}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic false, :max-fixed-arity 6} {:tag any, :variadic false, :max-fixed-arity 7} {:tag any, :variadic false, :max-fixed-arity 8} {:tag any, :variadic false, :max-fixed-arity 9} {:tag any, :variadic false, :max-fixed-arity 10} {:tag any, :variadic false, :max-fixed-arity 11} {:tag any, :variadic false, :max-fixed-arity 12} {:tag any, :variadic false, :max-fixed-arity 13} {:tag any, :variadic false, :max-fixed-arity 14} {:tag any, :variadic false, :max-fixed-arity 15} {:tag any, :variadic false, :max-fixed-arity 16} {:tag any, :variadic false, :max-fixed-arity 17} {:tag any, :variadic false, :max-fixed-arity 18} {:tag any, :variadic false, :max-fixed-arity 19} {:tag any, :variadic false, :max-fixed-arity 20} {:tag any, :variadic false, :max-fixed-arity 21} {:tag any, :variadic false, :max-fixed-arity 22}), :line 309, :end-line 313, :max-fixed-arity 22, :fn-var true, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :doc nil, :test true}, coll? {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Returns true if x satisfies ICollection", :tag boolean, :end-column 21, :end-line 1744, :column 16, :line 1744, :file "cljs/core.cljs"}, :name cljs.core/coll?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1744, :ret-tag boolean, :end-line 1744, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection", :test true}, get-in {:protocol-inline nil, :meta {:arglists (quote ([m ks] [m ks not-found])), :static true, :added "1.2", :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :end-column 13, :end-line 4366, :column 7, :line 4366, :file "cljs/core.cljs"}, :added "1.2", :name cljs.core/get-in, :variadic false, :file "cljs/core.cljs", :end-column 13, :static true, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 4366, :end-line 4366, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :test true}, fnext {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Same as (first (next x))", :end-column 12, :end-line 1400, :column 7, :line 1400, :file "cljs/core.cljs"}, :name cljs.core/fnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1400, :end-line 1400, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IList {:meta {:protocol-info {:methods {}}, :protocol-symbol true, :doc "Marker interface indicating a persistent list", :end-column 19, :end-line 490, :column 14, :line 490, :file "cljs/core.cljs"}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column 1, :line 490, :protocol-info {:methods {}}, :info nil, :end-line 490, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list", :test true}, List {:meta {:declared true, :end-column 34, :end-line 1224, :column 30, :line 1224, :file "cljs/core.cljs"}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2538, :record false, :declared true, :end-line 2538, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, -val {:protocol-inline nil, :meta {:arglists (quote ([coll])), :doc "Returns the value of the map entry.", :protocol cljs.core/IMapEntry, :end-column 8, :end-line 416, :column 4, :line 416, :file "cljs/core.cljs"}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 412, :end-line 416, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry.", :test true}, bytes {:protocol-inline nil, :meta {:arglists (quote ([x])), :end-column 12, :end-line 2319, :column 7, :line 2319, :file "cljs/core.cljs"}, :name cljs.core/bytes, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2319, :end-line 2319, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->ObjMap {:protocol-inline nil, :meta {:arglists (quote ([meta keys strobj update-count __hash])), :factory :positional, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :end-column 16, :end-line 5349, :column 10, :line 5349, :file "cljs/core.cljs"}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ObjMap, :variadic false, :max-fixed-arity 5}), :line 5349, :end-line 5349, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, compare-symbols {:protocol-inline nil, :meta {:arglists (quote ([a b])), :private true, :end-column 23, :end-line 802, :column 8, :line 802, :file "cljs/core.cljs"}, :private true, :name cljs.core/compare-symbols, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 802, :end-line 802, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -seq {:protocol-inline nil, :meta {:arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty.", :protocol cljs.core/ISeqable, :tag clj-or-nil, :end-column 20, :end-line 484, :column 16, :line 484, :file "cljs/core.cljs"}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 482, :ret-tag clj-or-nil, :end-line 484, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty.", :test true}}, :require-macros nil, :cljs.analyzer/constants {:order [:flush-on-newline :readably :meta :dup :print-length :else :default :validator :cljs.core/not-found :cljs.core/none :more-marker :alt-impl :fallback-impl :keywordize-keys :parents :descendants :ancestors :ok :no-test], :seen #{:meta :dup :else :cljs.core/none :validator :default :fallback-impl :flush-on-newline :no-test :descendants :ancestors :readably :more-marker :print-length :ok :parents :alt-impl :keywordize-keys :cljs.core/not-found}}, :doc nil}