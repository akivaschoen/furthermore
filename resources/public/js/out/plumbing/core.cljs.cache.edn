;; Analyzed by ClojureScript 0.0-3119
{:use-macros {lazy-get plumbing.core, for-map plumbing.core}, :excludes #{update}, :macros {as->> {:ns plumbing.core, :name plumbing.core/as->>, :file "plumbing/core.clj", :column 1, :line 320, :macro true, :arglists ([name & forms-and-expr]), :doc "Like as->, but can be used in double arrow."}, ?>> {:ns plumbing.core, :name plumbing.core/?>>, :file "plumbing/core.clj", :column 1, :line 286, :macro true, :arglists ([do-it? & args]), :doc "Conditional double-arrow operation (->> nums (?>> inc-all? (map inc)))"}, if-letk {:ns plumbing.core, :name plumbing.core/if-letk, :file "plumbing/core.clj", :column 1, :line 405, :macro true, :arglists ([bindings then] [bindings then else]), :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of\n  test, if not, yields else"}, fnk {:ns plumbing.core, :name plumbing.core/fnk, :file "plumbing/core.clj", :column 1, :line 429, :macro true, :arglists ([& args]), :doc "Keyword fn, using letk.  Generates a prismatic/schema schematized fn that\n   accepts a single explicit map i.e., (f {:foo :bar}).\n\n   Explicit top-level map structure will be recorded in output spec, or\n   to capture implicit structure use an explicit prismatic/schema hint on the\n   function name.\n\n   Individual inputs can also be schematized by putting :- schemas after the\n   binding symbol.  Schemas can also be used on & more symbols to describe\n   additional map inputs, or on entire [] bindings to override the automatically\n   generated schema for the contents (caveat emptor).\n\n   By default, input schemas allow for arbitrary additional mappings\n   ({s/Keyword s/Any}) unless explicit binding or & more schemas are provided."}, defnk {:ns plumbing.core, :name plumbing.core/defnk, :file "plumbing/core.clj", :column 1, :line 451, :macro true, :arglists ([& defnk-args]), :doc "Analogy: fn:fnk :: defn::defnk"}, memoized-fn {:ns plumbing.core, :name plumbing.core/memoized-fn, :file "plumbing/core.clj", :column 1, :line 325, :macro true, :arglists ([name args & body]), :doc "Like fn, but memoized (including recursive calls).\n\n   The clojure.core memoize correctly caches recursive calls when you do a top-level def\n   of your memoized function, but if you want an anonymous fibonacci function, you must use\n   memoized-fn rather than memoize to cache the recursive calls."}, <- {:ns plumbing.core, :name plumbing.core/<-, :file "plumbing/core.clj", :column 1, :line 310, :macro true, :arglists ([& body]), :doc "Converts a ->> to a ->\n\n   (->> (range 10) (map inc) (<- (doto prn)) (reduce +))\n\n   Jason W01fe is happy to give a talk anywhere any time on\n   the calculus of arrow macros"}, when-letk {:ns plumbing.core, :name plumbing.core/when-letk, :file "plumbing/core.clj", :column 1, :line 422, :macro true, :arglists ([bindings & body]), :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test"}, lazy-get {:ns plumbing.core, :name plumbing.core/lazy-get, :file "plumbing/core.clj", :column 1, :line 105, :macro true, :arglists ([m k d]), :doc "Like get but lazy about default"}, fn-> {:ns plumbing.core, :name plumbing.core/fn->, :file "plumbing/core.clj", :column 1, :line 300, :macro true, :arglists ([& body]), :doc "Equivalent to `(fn [x] (-> x ~@body))"}, letk {:ns plumbing.core, :name plumbing.core/letk, :file "plumbing/core.clj", :column 1, :line 375, :macro true, :arglists ([bindings & body]), :doc "Keyword let.  Accepts an interleaved sequence of binding forms and map forms like:\n   (letk [[a {b 2} [:f g h] c d {e 4} :as m & more] a-map ...] & body)\n   a, c, d, and f are required keywords, and letk will barf if not in a-map.\n   b and e are optional, and will be bound to default values if not present.\n   g and h are required keys in the map found under :f.\n   m will be bound to the entire map (a-map).\n   more will be bound to all the unbound keys (ie (dissoc a-map :a :b :c :d :e)).\n   :as and & are both optional, but must be at the end in the specified order if present.\n   The same symbol cannot be bound multiple times within the same destructing level.\n\n   Optional values can reference symbols bound earlier within the same binding, i.e.,\n   (= [2 2] (let [a 1] (letk [[a {b a}] {:a 2}] [a b]))) but\n   (= [2 1] (let [a 1] (letk [[{b a} a] {:a 2}] [a b])))\n\n   If present, :as and :& symbols are bound before other symbols within the binding."}, for-map {:ns plumbing.core, :name plumbing.core/for-map, :file "plumbing/core.clj", :column 1, :line 22, :macro true, :arglists ([seq-exprs key-expr val-expr] [m-sym seq-exprs key-expr val-expr]), :doc "Like 'for' for building maps. Same bindings except the body should have a\n  key-expression and value-expression. If a key is repeated, the last\n  value (according to \"for\" semantics) will be retained.\n\n  (= (for-map [i (range 2) j (range 2)] [i j] (even? (+ i j)))\n     {[0 0] true, [0 1] false, [1 0] false, [1 1] true})\n\n  An optional symbol can be passed as a first argument, which will be\n  bound to the transient map containing the entries produced so far."}, ?> {:ns plumbing.core, :name plumbing.core/?>, :file "plumbing/core.clj", :column 1, :line 293, :macro true, :arglists ([arg do-it? & rest]), :doc "Conditional single-arrow operation (-> m (?> add-kv? (assoc :k :v)))"}, fn->> {:ns plumbing.core, :name plumbing.core/fn->>, :file "plumbing/core.clj", :column 1, :line 305, :macro true, :arglists ([& body]), :doc "Equivalent to `(fn [x] (->> x ~@body))"}}, :name plumbing.core, :imports nil, :requires {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, schema.utils schema.utils, schema-utils schema.utils}, :uses nil, :defs {dissoc-in {:protocol-inline nil, :meta {:arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", :end-column 16, :end-line 79, :column 7, :line 79, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/dissoc-in, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 16, :method-params ([m p__18596]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2}), :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", :test true}, rsort-by {:doc "Like sort-by, but prefers higher values rather than lower ones.", :meta {:end-column 14, :end-line 279, :column 6, :line 279, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :file "resources/public/js/out/plumbing/core.cljs", :line 279, :column 1, :end-line 279, :end-column 14, :test true, :name plumbing.core/rsort-by}, +none+ {:meta {:private true, :end-column 22, :end-line 15, :column 16, :line 15, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :private true, :name plumbing.core/+none+, :file "resources/public/js/out/plumbing/core.cljs", :end-column 22, :column 1, :line 15, :end-line 15, :doc "A sentinel value representing missing portions of the input data.", :test true}, millis {:protocol-inline nil, :meta {:arglists (quote ([])), :end-column 13, :end-line 362, :column 7, :line 362, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/millis, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 0}), :line 362, :end-line 362, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, swap-pair! {:protocol-inline nil, :meta {:arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :end-column 17, :end-line 345, :column 7, :line 345, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/swap-pair!, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 17, :method-params ([a f] [a f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2} {:tag cljs.core/IVector, :variadic true, :max-fixed-arity 2}), :line 345, :end-line 345, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :test true}, keywordize-map {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", :end-column 21, :end-line 90, :column 7, :line 90, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/keywordize-map, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj cljs.core/LazySeq}, :variadic false, :max-fixed-arity 1}), :line 90, :end-line 90, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", :test true}, get-and-set! {:protocol-inline nil, :meta {:arglists (quote ([a new-val])), :doc "Like reset! but returns old-val", :end-column 19, :end-line 357, :column 7, :line 357, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/get-and-set!, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 19, :method-params ([a new-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 357, :end-line 357, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-val])), :doc "Like reset! but returns old-val", :test true}, positions {:protocol-inline nil, :meta {:arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))", :end-column 16, :end-line 197, :column 7, :line 197, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/positions, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 16, :method-params ([f s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 197, :end-line 197, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))", :test true}, sum {:protocol-inline nil, :meta {:arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :end-column 10, :end-line 180, :column 7, :line 180, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/sum, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 10, :method-params ([f xs] [xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 1}), :line 180, :end-line 180, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :test true}, conj-when {:protocol-inline nil, :meta {:arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :end-column 16, :end-line 264, :column 7, :line 264, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/conj-when, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 16, :method-params ([coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic false, :max-fixed-arity 2} {:tag #{nil clj}, :variadic true, :max-fixed-arity 2}), :line 264, :end-line 264, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :test true}, distinct-by {:protocol-inline nil, :meta {:arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", :end-column 18, :end-line 222, :column 7, :line 222, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/distinct-by, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 18, :method-params ([f xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 222, :end-line 222, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", :test true}, safe-get-in {:protocol-inline nil, :meta {:arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found", :end-column 18, :end-line 119, :column 7, :line 119, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/safe-get-in, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 18, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 119, :end-line 119, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found", :test true}, indexed {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s", :end-column 14, :end-line 192, :column 7, :line 192, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/indexed, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 192, :end-line 192, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s", :test true}, cons-when {:protocol-inline nil, :meta {:arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy.", :end-column 16, :end-line 274, :column 7, :line 274, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/cons-when, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 16, :method-params ([x s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Cons}, :variadic false, :max-fixed-arity 2}), :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy.", :test true}, mapply {:protocol-inline nil, :meta {:arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :end-column 13, :end-line 366, :column 7, :line 366, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/mapply, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 13, :method-params ([f m] [f arg args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 366, :end-line 366, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :test true}, map-keys {:protocol-inline nil, :meta {:arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m", :end-column 15, :end-line 62, :column 7, :line 62, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/map-keys, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 62, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m", :test true}, interleave-all {:protocol-inline nil, :meta {:arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :end-column 21, :end-line 249, :column 7, :line 249, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/interleave-all, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 21, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 0}), :line 249, :end-line 249, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :test true}, update {:protocol-inline nil, :meta {:arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n  Like update-in, but for updating a single top-level key.\n  Any additional args will be passed to f after the value.", :end-column 13, :end-line 41, :column 7, :line 41, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/update, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 13, :method-params ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic true, :max-fixed-arity 5}), :line 41, :end-line 41, :max-fixed-arity 5, :fn-var true, :arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n  Like update-in, but for updating a single top-level key.\n  Any additional args will be passed to f after the value.", :test true}, grouped-map {:protocol-inline nil, :meta {:arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", :end-column 18, :end-line 143, :column 7, :line 143, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/grouped-map, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 18, :method-params ([key-fn map-fn coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 143, :end-line 143, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", :test true}, count-when {:protocol-inline nil, :meta {:arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds", :end-column 17, :end-line 259, :column 7, :line 259, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/count-when, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 17, :method-params ([pred xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 259, :end-line 259, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds", :test true}, aconcat {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) ", :end-column 14, :end-line 158, :column 7, :line 158, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/aconcat, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 158, :end-line 158, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) ", :test true}, singleton {:protocol-inline nil, :meta {:arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element", :end-column 16, :end-line 185, :column 7, :line 185, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/singleton, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 16, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 185, :end-line 185, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element", :test true}, map-from-keys {:protocol-inline nil, :meta {:arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks", :end-column 20, :end-line 69, :column 7, :line 69, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/map-from-keys, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 20, :method-params ([f ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 69, :end-line 69, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks", :test true}, map-vals {:protocol-inline nil, :meta {:arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type", :end-column 15, :end-line 51, :column 7, :line 51, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/map-vals, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any}, :variadic false, :max-fixed-arity 2}), :line 51, :end-line 51, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type", :test true}, assoc-when {:protocol-inline nil, :meta {:arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :end-column 17, :end-line 126, :column 7, :line 126, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/assoc-when, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 17, :method-params ([m kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 126, :end-line 126, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :test true}, map-from-vals {:protocol-inline nil, :meta {:arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs", :end-column 20, :end-line 74, :column 7, :line 74, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/map-from-vals, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 20, :method-params ([f vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 74, :end-line 74, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs", :test true}, update-in-when {:protocol-inline nil, :meta {:arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :end-column 21, :end-line 135, :column 7, :line 135, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/update-in-when, :variadic true, :file "resources/public/js/out/plumbing/core.cljs", :end-column 21, :method-params ([m key-seq f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic true, :max-fixed-arity 3}), :line 135, :end-line 135, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :test true}, unchunk {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :end-column 14, :end-line 163, :column 7, :line 163, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/unchunk, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 163, :end-line 163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :test true}, safe-get {:protocol-inline nil, :meta {:arglists (quote ([m k])), :doc "Like get but throw an exception if not found", :end-column 15, :end-line 112, :column 7, :line 112, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/core.cljs"}, :name plumbing.core/safe-get, :variadic false, :file "resources/public/js/out/plumbing/core.cljs", :end-column 15, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 112, :end-line 112, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :doc "Like get but throw an exception if not found", :test true}}, :require-macros {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, plumbing.core plumbing.core}, :cljs.analyzer/constants {:order [:plumbing.core/missing :else], :seen #{:plumbing.core/missing :else}}, :doc "Utility belt for Clojure in the wild"}